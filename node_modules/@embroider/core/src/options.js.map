{"version":3,"file":"options.js","sourceRoot":"","sources":["options.ts"],"names":[],"mappings":";;;AA8HA,SAAgB,mBAAmB,CAAC,OAAiB;IACnD,IAAI,QAAQ,GAAG;QACb,aAAa,EAAE,KAAK;QACpB,eAAe,EAAE,KAAK;QACtB,gBAAgB,EAAE,KAAK;QACvB,aAAa,EAAE,EAAE;QACjB,cAAc,EAAE,EAAE;QAClB,SAAS,EAAE,EAAE;QACb,WAAW,EAAE,EAAE;QACf,gBAAgB,EAAE,KAAc;KACjC,CAAC;IACF,IAAI,OAAO,EAAE;QACX,OAAO,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;KACzC;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC;AAfD,kDAeC","sourcesContent":["export default interface Options {\n  // When true, we statically resolve all template helpers at build time. This\n  // causes unused helpers to be left out of the build (\"tree shaking\" of\n  // helpers).\n  //\n  // Defaults to false, which gives you greater compatibility with classic Ember\n  // apps at the cost of bigger builds.\n  //\n  // Enabling this is a prerequisite for route splitting.\n  staticHelpers?: boolean;\n\n  // When true, we statically resolve all modifiers at build time. This\n  // causes unused modifiers to be left out of the build (\"tree shaking\" of\n  // modifiers).\n  //\n  // Defaults to false, which gives you greater compatibility with classic Ember\n  // apps at the cost of bigger builds.\n  //\n  // Enabling this is a prerequisite for route splitting.\n  staticModifiers?: boolean;\n\n  // When true, we statically resolve all components at build time. This causes\n  // unused components to be left out of the build (\"tree shaking\" of\n  // components).\n  //\n  // Defaults to false, which gives you greater compatibility with classic Ember\n  // apps at the cost of bigger builds.\n  //\n  // Enabling this is a prerequisite for route splitting.\n  staticComponents?: boolean;\n\n  // Enables per-route code splitting. Any route names that match these patterns\n  // will be split out of the initial app payload. If you use this, you must\n  // also add @embroider/router to your app. See [@embroider/router's\n  // README](https://github.com/embroider-build/embroider/blob/main/packages/router/README.md)\n  splitAtRoutes?: (RegExp | string)[];\n\n  // Every file within your application's `app` directory is categorized as a\n  // component, helper, modifier, route, route template, controller, or \"other\".\n  //\n  // This option lets you decide which \"other\" files should be loaded\n  // statically. By default, all \"other\" files will be included in the build and\n  // registered with Ember's runtime loader, because we can't know if somebody\n  // is going to try to access them dynamically via Ember's resolver or AMD\n  // runtime `require`.\n  //\n  // If you know that your files are only ever imported, you can list them here\n  // and then they will only be included exactly where they're needed.\n  //\n  // Provide a list of directories or files relative to `/app`. For example\n  //\n  //     staticAppPaths: ['lib']\n  //\n  // means that everything under your-project/app/lib will be loaded statically.\n  //\n  // This option has no effect on components (which are governed by\n  // staticComponents), helpers (which are governed by staticHelpers), modifiers\n  // (which are governed by staticModifiers) or the route-specific files (routes,\n  // route templates, and controllers which are governed by splitAtRoutes).\n  staticAppPaths?: string[];\n\n  // By default, all modules that get imported into the app go through Babel, so\n  // that all code will conform with your Babel targets. This option allows you\n  // to turn Babel off for a particular package. You might need this to work\n  // around a transpiler bug or you might use this as a build-performance\n  // optimization if you've manually verified that a particular package doesn't\n  // need transpilation to be safe in your target browsers.\n  skipBabel?: { package: string; semverRange?: string }[];\n\n  // This is a performance optimization that can help you avoid the \"Your build\n  // is slower because some babel plugins are non-serializable\" penalty. If you\n  // provide the locations of known non-serializable objects, we can discover\n  // them and make them serializable.\n  //\n  // resolve is a list of paths to resolve, in a chain. This lets you resolve\n  // your dependencies' dependencies, like: resolve: ['your-dependency',\n  // 'inner-dependency/lib/transform']\n  //\n  // useMethod optionally lets you pick which property within the module to use.\n  // If not provided, we use the module.exports itself.\n  pluginHints?: { resolve: string[]; useMethod?: string }[];\n\n  // Ember classically used a runtime AMD module loader.\n  //\n  // Embroider *can* locate the vast majority of modules statically, but when an\n  // addon is doing something highly dynamic (like injecting AMD `define()`\n  // statements directly into a <script>), we still may not be able to locate\n  // them. So Embroider can emit a placeholder shim for the missing module that\n  // attempts to locate it at runtime in the classic AMD loader.\n  //\n  // This shim can be generated as commonJS (cjs) or an ES module (es). The\n  // default is cjs.\n  //\n  // CJS is useful when you're building in an environment that is tolerant of\n  // mixed CJS and ES modules (like Webpack), because the set of exported names\n  // from the module doesn't need to be known in advance. For this reason, CJS\n  // shims are generated on-demand and are fully-automatic. This is the default\n  // for maximum backward-compatibility.\n  //\n  // ES is useful when you're building in a strict ES module environment (like\n  // Vite). It's fully spec-defined and doesn't suffer interoperability\n  // complexities. The downside is, we can only emit a correct shim for a module\n  // if you tell embroider what set of names it exports. Example:\n\n  // emberExternals: {\n  //   es: [\n  //     // import { first, second  } from \"my-library\";\n  //     ['my-library', ['first', 'second']],\n  //     // import Example from \"my-library/components/example\";\n  //     ['my-library/components/example', ['default']]\n  //   ];\n  // }\n\n  // It is not recommended to use `es` mode without also using\n  // staticEmberSource, because without staticEmberSource ember itself needs\n  // many external shims.\n  //\n  // false means we don't do any external shimming.\n  amdCompatibility?:\n    | false\n    | 'cjs'\n    | {\n        es: [string, string[]][];\n      };\n}\n\nexport function optionsWithDefaults(options?: Options): Required<Options> {\n  let defaults = {\n    staticHelpers: false,\n    staticModifiers: false,\n    staticComponents: false,\n    splitAtRoutes: [],\n    staticAppPaths: [],\n    skipBabel: [],\n    pluginHints: [],\n    amdCompatibility: 'cjs' as const,\n  };\n  if (options) {\n    return Object.assign(defaults, options);\n  }\n  return defaults;\n}\n"]}