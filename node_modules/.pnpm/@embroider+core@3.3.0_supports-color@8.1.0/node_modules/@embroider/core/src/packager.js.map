{"version":3,"file":"packager.js","sourceRoot":"","sources":["packager.ts"],"names":[],"mappings":";;;AACA,kEAAqD;AACrD,uCAAwC;AACxC,mCAAmC;AACnC,+BAA4B;AAoE5B,SAAgB,yBAAyB,CAAC,OAAgB,EAAE,WAAgB;IAC1E,IAAI,OAAO,CAAC,OAAO,KAAK,UAAU,EAAE;QAClC,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,WAAW,CAAC,CAAC;QAC7C,IAAI,WAAW,CAAC,OAAO,EAAE;YACvB,WAAW,CAAC,OAAO,GAAG,WAAW,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;SACnD;aAAM;YACL,WAAW,CAAC,OAAO,GAAG,EAAE,CAAC;SAC1B;QACD,IAAI,WAAW,GAAG,WAAW,CAAC,OAAO,CAAC,IAAI,CACxC,CAAC,CAAM,EAAE,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,2BAA2B,CACzE,CAAC;QACF,IAAI,WAAW,EAAE;YACf,IAAI,mBAAmB,GAAG,IAAA,kBAAS,EAAC,WAAW,CAAC,CAAC;YACjD,mBAAmB,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,QAAQ,GAAG,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC;YACnE,WAAW,CAAC,OAAO,CAAC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE,CAAC,EAAE,mBAAmB,CAAC,CAAC;SAC9F;KACF;IACD,OAAO,WAAW,CAAC;AACrB,CAAC;AAlBD,8DAkBC;AAED;;GAEG;AACH,SAAgB,UAAU,CAAC,gBAAwB;IACjD,IAAI,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAA,uBAAY,EAAC,IAAA,WAAI,EAAC,gBAAgB,EAAE,cAAc,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;IACnF,OAAO,GAA0D,CAAC;AACpE,CAAC;AAHD,gCAGC;AAED;;;;GAIG;AACH,SAAgB,mBAAmB,CAAC,IAAY;IAC9C,OAAO,IAAA,WAAI,EAAC,yBAAM,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;AACzC,CAAC;AAFD,kDAEC","sourcesContent":["import type { AppMeta } from '@embroider/shared-internals';\nimport { tmpdir } from '@embroider/shared-internals';\nimport { readFileSync } from 'fs-extra';\nimport { cloneDeep } from 'lodash';\nimport { join } from 'path';\n\n// This is a collection of flags that convey what kind of build you want. They\n// are intended to be generic across Packagers, and it's up to Packager authors\n// to support each option (or not).\nexport interface Variant {\n  // descriptive name that can be used by the packager to label which output\n  // goes with which variant.\n  name: string;\n\n  // Which runtime should this build work in? Dev builds will typically be \"all\"\n  // because we produce a single build that works in browser and fastboot. But\n  // production builds can be divided into a browser-only variant and a\n  // fastboot-only variant so that each can be separately optimized.\n  //\n  // Note that if you build *only* a fastboot variant, you're unlikely to end up\n  // with any assets that can boot and run in the browser too, so the typical\n  // thing to do is to have to two variants and for the packager to use the\n  // assets from the browser build to generate browser-facing <script> tags in\n  // the output of the fastboot build.\n  runtime: 'all' | 'browser' | 'fastboot';\n\n  // true if this build should be optimized for production, at the cost of\n  // slower builds and/or worse debuggability\n  optimizeForProduction: boolean;\n}\n\nexport interface PackagerConstructor<Options> {\n  new (\n    // where on disk the packager will find the app it's supposed to build. The\n    // app and its addons will necessarily already be in v2 format, which is\n    // what makes a Packager a cleanly separable stage that needs only a small\n    // amount of ember-specific knowledge.\n    inputPath: string,\n    // where the packager should write the packaged app.\n    outputPath: string,\n    // list of active build variants. There is always at least one variant, but\n    // there can be many.\n    //\n    // The main requirement for correctness is that the Packager is required to\n    // apply each variant to the babel and template-compiler configs that it\n    // finds in the app in order to build that variant.\n    //\n    // It is up to each Packager to decide how to combine the output from the\n    // multiple variants. It might choose to just put them in separate\n    // subdirectories of `outputPath`, or it might know how to combine them\n    // correctly into one build that will run each variant under the appropriate\n    // conditions.\n    //\n    // Not all packagers will support all arbitrary combinations of variants.\n    variants: Variant[],\n    // if possible, the packager should direct its console output through this\n    // hook.\n    consoleWrite: (message: string) => void,\n    // A packager can have whatever custom options type it wants here. If the\n    // packager is based on a third-party tool, this is where that tool's\n    // configuration can go.\n    options?: Options\n  ): Packager;\n\n  // a description for this packager that aids debugging & profiling\n  annotation: string;\n}\n\nexport interface Packager {\n  build(): Promise<void>;\n}\n\nexport function applyVariantToBabelConfig(variant: Variant, babelConfig: any) {\n  if (variant.runtime === 'fastboot') {\n    babelConfig = Object.assign({}, babelConfig);\n    if (babelConfig.plugins) {\n      babelConfig.plugins = babelConfig.plugins.slice();\n    } else {\n      babelConfig.plugins = [];\n    }\n    let macroPlugin = babelConfig.plugins.find(\n      (p: any) => Array.isArray(p) && p[1] && p[1].embroiderMacrosConfigMarker\n    );\n    if (macroPlugin) {\n      let modifiedMacroPlugin = cloneDeep(macroPlugin);\n      modifiedMacroPlugin[1].globalConfig.fastboot = { isRunning: true };\n      babelConfig.plugins.splice(babelConfig.plugins.indexOf(macroPlugin), 1, modifiedMacroPlugin);\n    }\n  }\n  return babelConfig;\n}\n\n/**\n * Get the app meta-data for a package\n */\nexport function getAppMeta(pathToVanillaApp: string) {\n  let pkg = JSON.parse(readFileSync(join(pathToVanillaApp, 'package.json'), 'utf8'));\n  return pkg as unknown as { name: string; 'ember-addon': AppMeta };\n}\n\n/**\n * Get the path to a cache directory in the recommended location\n *\n * This ensures they have exactly the same lifetime as some of embroider's own caches.\n */\nexport function getPackagerCacheDir(name: string): string {\n  return join(tmpdir, 'embroider', name);\n}\n"]}