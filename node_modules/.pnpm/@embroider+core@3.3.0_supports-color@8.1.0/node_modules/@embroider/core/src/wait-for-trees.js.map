{"version":3,"file":"wait-for-trees.js","sourceRoot":"","sources":["wait-for-trees.ts"],"names":[],"mappings":"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","sourcesContent":["import BroccoliPlugin from 'broccoli-plugin';\nimport type { Node } from 'broccoli-node-api';\n\n/*\n  Takes some named broccoli trees and/or lists of broccoli trees and gives you\n  the resulting inputPaths once those trees are built. Example:\n\n    import { Node } from 'broccoli-node-api';;\n\n    interface MyInputs<T> {\n      codeFromMyApp: T,\n      codeFromMyAddons: T[]\n    }\n\n    function(trees: MyInputs<Node>): Node {\n      return WaitForTrees(trees, build);\n    }\n\n    async function build(paths: MyInputs<string>) {\n      // paths.someTree is a string\n      // paths.otherTrees is a string[]\n    }\n\n*/\nexport default class WaitForTrees<NamedTrees> extends BroccoliPlugin {\n  constructor(\n    private trees: NamedTrees,\n    annotation: string,\n    private buildHook: (trees: OutputPaths<NamedTrees>, changed: Map<string, boolean>) => Promise<void>\n  ) {\n    super(flatTrees(trees), {\n      persistentOutput: true,\n      needsCache: false,\n      annotation: annotation,\n      trackInputChanges: true,\n    });\n  }\n\n  async build(detail?: { changedNodes: boolean[] }) {\n    let result: { [treeName: string]: string | string[] } = {};\n    let changedMap = new Map();\n\n    let inputPathCounter = 0;\n    for (let entry of findTrees(this.trees)) {\n      if (entry.single) {\n        result[entry.name] = this.inputPaths[inputPathCounter];\n        let didChange = detail ? detail.changedNodes[inputPathCounter] : true;\n        changedMap.set(this.inputPaths[inputPathCounter], didChange);\n        inputPathCounter += 1;\n      } else if (entry.multi) {\n        let sliced = this.inputPaths.slice(inputPathCounter, inputPathCounter + entry.multi.length);\n\n        result[entry.name] = sliced.map(slice => {\n          let didChange = detail ? detail.changedNodes[inputPathCounter] : true;\n          changedMap.set(slice, didChange);\n          inputPathCounter++;\n          return slice;\n        });\n      }\n    }\n    return this.buildHook(result as unknown as OutputPaths<NamedTrees>, changedMap);\n  }\n}\n\nexport type OutputPaths<NamedTrees> = {\n  [P in keyof NamedTrees]: NamedTrees[P] extends Node ? string : NamedTrees[P] extends Node[] ? string[] : never;\n};\n\nfunction isTree(x: any): x is Node {\n  return x && typeof x.__broccoliGetInfo__ === 'function';\n}\n\nfunction* findTrees<NamedTrees>(trees: NamedTrees): IterableIterator<{ name: string; single?: Node; multi?: Node[] }> {\n  for (let [name, value] of Object.entries(trees as Record<string, unknown>)) {\n    if (Array.isArray(value)) {\n      let stringTrees = value.filter(t => typeof t === 'string');\n      if (stringTrees.length > 0) {\n        throw new Error(`found strings instead of broccoli trees for ${name}: ${value}`);\n      }\n      yield { name, multi: value.filter(isTree) };\n    } else if (isTree(value)) {\n      yield { name, single: value };\n    } else if (typeof value === 'string') {\n      throw new Error(`found a string when we expected a broccoli tree for ${name}: ${value}`);\n    }\n  }\n}\n\nfunction flatTrees<NamedTrees>(trees: NamedTrees) {\n  let output: Node[] = [];\n  for (let value of findTrees(trees)) {\n    if (value.multi) {\n      output = output.concat(value.multi);\n    } else if (value.single) {\n      output.push(value.single);\n    }\n  }\n  return output;\n}\n"]}