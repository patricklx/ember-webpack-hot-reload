"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePlugin = void 0;
const babel_import_util_1 = require("babel-import-util");
const expression_parser_1 = require("./expression-parser");
const js_utils_1 = require("./js-utils");
const scope_locals_1 = require("./scope-locals");
const syntax_1 = require("@glimmer/syntax");
__exportStar(require("./public-types"), exports);
const INLINE_PRECOMPILE_MODULES = [
    {
        moduleName: 'ember-cli-htmlbars',
        export: 'hbs',
        allowTemplateLiteral: true,
    },
    {
        moduleName: 'ember-cli-htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
    },
    {
        moduleName: 'htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
    },
    {
        moduleName: '@ember/template-compilation',
        export: 'precompileTemplate',
        enableScope: true,
    },
    {
        moduleName: '@ember/template-compiler',
        export: 'template',
        enableScope: true,
        rfc931Support: 'polyfilled',
    },
];
function normalizeOpts(options) {
    var _a;
    if (((_a = options.targetFormat) !== null && _a !== void 0 ? _a : 'wire') === 'wire') {
        let { compiler } = options;
        if (!compiler) {
            throw new Error(`when targetFormat==="wire" you must set the compiler or compilerPath option`);
        }
        return Object.assign(Object.assign({ outputModuleOverrides: {}, enableLegacyModules: [], transforms: [] }, options), { targetFormat: 'wire', compiler });
    }
    else {
        return Object.assign(Object.assign({ outputModuleOverrides: {}, enableLegacyModules: [], transforms: [] }, options), { targetFormat: 'hbs' });
    }
}
function makePlugin(loadOptions) {
    return function htmlbarsInlinePrecompile(babel) {
        let t = babel.types;
        return {
            visitor: {
                Program: {
                    enter(path, state) {
                        state.normalizedOpts = normalizeOpts(loadOptions(state.opts));
                        state.templateFactory = templateFactoryConfig(state.normalizedOpts);
                        state.util = new babel_import_util_1.ImportUtil(t, path);
                        state.program = path;
                        state.recursionGuard = new Set();
                    },
                    exit(_path, state) {
                        if (state.normalizedOpts.targetFormat === 'wire') {
                            for (let { moduleName, export: exportName } of configuredModules(state)) {
                                state.util.removeImport(moduleName, exportName);
                            }
                        }
                    },
                },
                TaggedTemplateExpression(path, state) {
                    let tagPath = path.get('tag');
                    if (!tagPath.isIdentifier()) {
                        return;
                    }
                    let config = referencesInlineCompiler(tagPath, state);
                    if (!config) {
                        return;
                    }
                    if (!config.allowTemplateLiteral) {
                        throw path.buildCodeFrameError(`Attempted to use \`${tagPath.node.name}\` as a template tag, but it can only be called as a function with a string passed to it: ${tagPath.node.name}('content here')`);
                    }
                    if (path.node.quasi.expressions.length) {
                        throw path.buildCodeFrameError('placeholders inside a tagged template string are not supported');
                    }
                    let template = path.node.quasi.quasis.map((quasi) => quasi.value.cooked).join('');
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, state.normalizedOpts, template, path, {}, config, undefined);
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, {}, config, undefined);
                    }
                },
                CallExpression(path, state) {
                    let calleePath = path.get('callee');
                    if (!calleePath.isIdentifier()) {
                        return;
                    }
                    let config = referencesInlineCompiler(calleePath, state);
                    if (!config) {
                        return;
                    }
                    if (state.recursionGuard.has(path.node)) {
                        return;
                    }
                    if (path.get('arguments').length > 2) {
                        throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string and any static options`);
                    }
                    let [firstArg, secondArg] = path.get('arguments');
                    let template;
                    switch (firstArg === null || firstArg === void 0 ? void 0 : firstArg.node.type) {
                        case 'StringLiteral':
                            template = firstArg.node.value;
                            break;
                        case 'TemplateLiteral':
                            if (firstArg.node.expressions.length) {
                                throw path.buildCodeFrameError('placeholders inside a template string are not supported');
                            }
                            else {
                                template = firstArg.node.quasis.map((quasi) => quasi.value.cooked).join('');
                            }
                            break;
                        case 'TaggedTemplateExpression':
                            throw path.buildCodeFrameError(`tagged template strings inside ${calleePath.node.name} are not supported`);
                        default:
                            throw path.buildCodeFrameError(`${calleePath.node.name} should be invoked with at least a single argument (the template string)`);
                    }
                    let userTypedOptions;
                    let backingClass;
                    if (!secondArg) {
                        userTypedOptions = {};
                    }
                    else {
                        if (!secondArg.isObjectExpression()) {
                            throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string, and any static options`);
                        }
                        userTypedOptions = new expression_parser_1.ExpressionParser(babel).parseObjectExpression(calleePath.node.name, secondArg, config.enableScope, Boolean(config.rfc931Support));
                        if (config.rfc931Support && userTypedOptions.component) {
                            backingClass = userTypedOptions.component;
                        }
                    }
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, state.normalizedOpts, template, path, userTypedOptions, config, backingClass);
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, userTypedOptions, config, backingClass);
                    }
                },
            },
        };
    };
}
exports.makePlugin = makePlugin;
function* configuredModules(state) {
    for (let moduleConfig of INLINE_PRECOMPILE_MODULES) {
        if (moduleConfig.moduleName !== '@ember/template-compilation' &&
            moduleConfig.moduleName !== '@ember/template-compiler' &&
            !state.normalizedOpts.enableLegacyModules.includes(moduleConfig.moduleName)) {
            continue;
        }
        yield moduleConfig;
    }
}
function referencesInlineCompiler(path, state) {
    for (let moduleConfig of configuredModules(state)) {
        if (path.referencesImport(moduleConfig.moduleName, moduleConfig.export)) {
            return moduleConfig;
        }
    }
    return undefined;
}
function runtimeErrorIIFE(babel, replacements) {
    let statement = babel.template(`(function() {\n  throw new Error('ERROR_MESSAGE');\n})();`)(replacements);
    return statement.expression;
}
function buildScopeLocals(userTypedOptions, formatOptions, templateContent) {
    if (formatOptions.rfc931Support && userTypedOptions.eval) {
        return discoverLocals(templateContent);
    }
    else if (userTypedOptions.scope) {
        return userTypedOptions.scope;
    }
    else {
        return new scope_locals_1.ScopeLocals();
    }
}
function discoverLocals(templateContent) {
    // this is wrong, but the right thing is unreleased in
    // https://github.com/glimmerjs/glimmer-vm/pull/1421, so for the moment I'm
    // sticking with the exact behavior that ember-templates-imports has.
    //
    // (the reason it's wrong is that the correct answer depends on not just the
    // template, but the ambient javascript scope. Anything in locals needs to win
    // over ember keywords. Otherwise we can never introduce new keywords.)
    let scopeLocals = new scope_locals_1.ScopeLocals();
    for (let local of (0, syntax_1.getTemplateLocals)(templateContent)) {
        if (local.match(/^[$A-Z_][0-9A-Z_$]*$/i)) {
            scopeLocals.add(local);
        }
    }
    return scopeLocals;
}
function buildPrecompileOptions(babel, target, state, template, userTypedOptions, config, scope) {
    let jsutils = new js_utils_1.JSUtils(babel, state, target, scope, state.util);
    let meta = Object.assign({ jsutils }, userTypedOptions === null || userTypedOptions === void 0 ? void 0 : userTypedOptions.meta);
    let output = {
        contents: template,
        // we've extended meta to add jsutils, but the types in @glimmer/syntax
        // don't account for extension
        meta: meta,
        // TODO: embroider's template-compiler allows this to be overriden to get
        // backward-compatible module names that don't match the real name of the
        // on-disk file. What's our plan for migrating people away from that?
        moduleName: state.filename,
        // This is here so it's *always* the real filename. Historically, there is
        // also `moduleName` but that did not match the real on-disk filename, it
        // was the notional runtime module name from classic ember builds.
        filename: state.filename,
        plugins: {
            // the cast is needed here only because our meta is extended. That is,
            // these plugins can access meta.jsutils.
            ast: state.normalizedOpts.transforms,
        },
    };
    for (let [key, value] of Object.entries(userTypedOptions)) {
        if (key !== 'scope') {
            // `scope` in the user-facing API becomes `locals` in the low-level
            // ember-template-compiler API
            output[key] = value;
        }
    }
    output.locals = scope.locals;
    if (config.rfc931Support) {
        output.strictMode = true;
    }
    return output;
}
// if scope has different keys and values, this function will remap the keys to the values
// you can see an example of this in the test "correctly handles scope if it contains keys and values"
function remapIdentifiers(ast, babel, scopeLocals) {
    if (!scopeLocals.needsRemapping()) {
        // do nothing if all keys are the same as their values
        return;
    }
    babel.traverse(ast, {
        Identifier(path) {
            if (scopeLocals.has(path.node.name) && path.node.name !== scopeLocals.get(path.node.name)) {
                // replace the path only if the key is different from the value
                path.replaceWith(babel.types.identifier(scopeLocals.get(path.node.name)));
            }
        },
    });
}
function insertCompiledTemplate(babel, state, opts, template, target, userTypedOptions, config, backingClass) {
    var _a;
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions, config, template);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, config, scopeLocals);
    let precompileResultString;
    // insertRuntimeErrors is legacy and not supported by the newer rfc931 form
    if (options.insertRuntimeErrors && !config.rfc931Support) {
        try {
            precompileResultString = opts.compiler.precompile(template, options);
        }
        catch (error) {
            target.replaceWith(runtimeErrorIIFE(babel, { ERROR_MESSAGE: error.message }));
            return;
        }
    }
    else {
        precompileResultString = opts.compiler.precompile(template, options);
    }
    let precompileResultAST = babel.parse(`var precompileResult = ${precompileResultString}; `, {
        babelrc: false,
        configFile: false,
    });
    remapIdentifiers(precompileResultAST, babel, scopeLocals);
    let templateExpression = precompileResultAST.program.body[0]
        .declarations[0].init;
    t.addComment(templateExpression, 'leading', `\n  ${template.replace(/\*\//g, '*\\/')}\n`, 
    /* line comment? */ false);
    let templateFactoryIdentifier = state.util.import(target, state.templateFactory.moduleName, state.templateFactory.exportName);
    let expression = t.callExpression(templateFactoryIdentifier, [templateExpression]);
    if (config.rfc931Support) {
        expression = t.callExpression(state.util.import(target, '@ember/component', 'setComponentTemplate'), [
            expression,
            (_a = backingClass === null || backingClass === void 0 ? void 0 : backingClass.node) !== null && _a !== void 0 ? _a : t.callExpression(state.util.import(target, '@ember/component/template-only', 'default', 'templateOnly'), []),
        ]);
    }
    target.replaceWith(expression);
}
function insertTransformedTemplate(babel, state, template, target, userTypedOptions, formatOptions, backingClass) {
    var _a;
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions, formatOptions, template);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, formatOptions, scopeLocals);
    let ast = (0, syntax_1.preprocess)(template, Object.assign(Object.assign({}, options), { mode: 'codemod' }));
    let transformed = (0, syntax_1.print)(ast, { entityEncoding: 'raw' });
    if (target.isCallExpression()) {
        target.get('arguments.0').replaceWith(t.stringLiteral(transformed));
        if (!scopeLocals.isEmpty()) {
            if (!formatOptions.enableScope) {
                maybePruneImport(state.util, target.get('callee'));
                target.set('callee', precompileTemplate(state.util, target));
            }
            updateScope(babel, target, scopeLocals);
        }
        if (formatOptions.rfc931Support === 'polyfilled') {
            maybePruneImport(state.util, target.get('callee'));
            target.set('callee', precompileTemplate(state.util, target));
            convertStrictMode(babel, target);
            removeEvalAndScope(target);
            target.node.arguments = target.node.arguments.slice(0, 2);
            state.recursionGuard.add(target.node);
            target.replaceWith(t.callExpression(state.util.import(target, '@ember/component', 'setComponentTemplate'), [
                target.node,
                (_a = backingClass === null || backingClass === void 0 ? void 0 : backingClass.node) !== null && _a !== void 0 ? _a : t.callExpression(state.util.import(target, '@ember/component/template-only', 'default', 'templateOnly'), []),
            ]));
        }
    }
    else {
        if (!scopeLocals.isEmpty()) {
            // need to add scope, so need to replace the backticks form with a call
            // expression to precompileTemplate
            maybePruneImport(state.util, target.get('tag'));
            let newCall = target.replaceWith(t.callExpression(precompileTemplate(state.util, target), [t.stringLiteral(transformed)]))[0];
            updateScope(babel, newCall, scopeLocals);
        }
        else {
            target.get('quasi').get('quasis.0').replaceWith(t.templateElement({ raw: transformed }));
        }
    }
}
function templateFactoryConfig(opts) {
    var _a;
    let moduleName = '@ember/template-factory';
    let exportName = 'createTemplateFactory';
    let overrides = (_a = opts.outputModuleOverrides[moduleName]) === null || _a === void 0 ? void 0 : _a[exportName];
    return overrides
        ? { exportName: overrides[0], moduleName: overrides[1] }
        : { exportName, moduleName };
}
function buildScope(babel, locals) {
    let t = babel.types;
    return t.arrowFunctionExpression([], t.objectExpression(locals
        .entries()
        .map(([name, identifier]) => t.objectProperty(t.identifier(name), t.identifier(identifier), false, true))));
}
function updateScope(babel, target, locals) {
    let t = babel.types;
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let scope = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'scope';
        });
        if (scope) {
            scope.set('value', buildScope(babel, locals));
        }
        else {
            secondArg.pushContainer('properties', t.objectProperty(t.identifier('scope'), buildScope(babel, locals)));
        }
    }
    else {
        target.pushContainer('arguments', t.objectExpression([t.objectProperty(t.identifier('scope'), buildScope(babel, locals))]));
    }
}
function removeEvalAndScope(target) {
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let evalProp = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'eval';
        });
        if (evalProp) {
            evalProp.remove();
        }
        let componentProp = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'component';
        });
        if (componentProp) {
            componentProp.remove();
        }
    }
}
// Given a call to template(), convert its "strict" argument into
// precompileTemplate's "strictMode" argument. They differ in name and default
// value.
function convertStrictMode(babel, target) {
    let t = babel.types;
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let strict = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'strict';
        });
        if (strict) {
            strict.set('key', t.identifier('strictMode'));
        }
        else {
            secondArg.pushContainer('properties', t.objectProperty(t.identifier('strictMode'), t.booleanLiteral(true)));
        }
    }
    else {
        target.pushContainer('arguments', t.objectExpression([t.objectProperty(t.identifier('strictMode'), t.booleanLiteral(true))]));
    }
}
function maybePruneImport(util, identifier) {
    if (!identifier.isIdentifier()) {
        return;
    }
    let binding = identifier.scope.getBinding(identifier.node.name);
    // this checks if the identifier (that we're about to remove) is used in
    // exactly one place.
    if ((binding === null || binding === void 0 ? void 0 : binding.referencePaths.reduce((count, path) => (path.removed ? count : count + 1), 0)) === 1) {
        let specifier = binding.path;
        if (specifier.isImportSpecifier()) {
            let declaration = specifier.parentPath;
            util.removeImport(declaration.node.source.value, name(specifier.node.imported));
        }
    }
    identifier.removed = true;
}
function precompileTemplate(util, target) {
    return util.import(target, '@ember/template-compilation', 'precompileTemplate');
}
function name(node) {
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    else {
        return node.name;
    }
}
exports.default = makePlugin((options) => options);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2luLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGx1Z2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0EseURBQStDO0FBQy9DLDJEQUF1RDtBQUN2RCx5Q0FBNEQ7QUFHNUQsaURBQTZDO0FBQzdDLDRDQUF5RjtBQUV6RixpREFBK0I7QUFZL0IsTUFBTSx5QkFBeUIsR0FBbUI7SUFDaEQ7UUFDRSxVQUFVLEVBQUUsb0JBQW9CO1FBQ2hDLE1BQU0sRUFBRSxLQUFLO1FBQ2Isb0JBQW9CLEVBQUUsSUFBSTtLQUMzQjtJQUNEO1FBQ0UsVUFBVSxFQUFFLHNDQUFzQztRQUNsRCxNQUFNLEVBQUUsU0FBUztRQUNqQixvQkFBb0IsRUFBRSxJQUFJO0tBQzNCO0lBQ0Q7UUFDRSxVQUFVLEVBQUUsNEJBQTRCO1FBQ3hDLE1BQU0sRUFBRSxTQUFTO1FBQ2pCLG9CQUFvQixFQUFFLElBQUk7S0FDM0I7SUFDRDtRQUNFLFVBQVUsRUFBRSw2QkFBNkI7UUFDekMsTUFBTSxFQUFFLG9CQUFvQjtRQUM1QixXQUFXLEVBQUUsSUFBSTtLQUNsQjtJQUNEO1FBQ0UsVUFBVSxFQUFFLDBCQUEwQjtRQUN0QyxNQUFNLEVBQUUsVUFBVTtRQUNsQixXQUFXLEVBQUUsSUFBSTtRQUNqQixhQUFhLEVBQUUsWUFBWTtLQUM1QjtDQUNGLENBQUM7QUErREYsU0FBUyxhQUFhLENBQUMsT0FBZ0I7O0lBQ3JDLElBQUksQ0FBQyxNQUFBLE9BQU8sQ0FBQyxZQUFZLG1DQUFJLE1BQU0sQ0FBQyxLQUFLLE1BQU0sRUFBRTtRQUMvQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQzNCLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDYixNQUFNLElBQUksS0FBSyxDQUNiLDZFQUE2RSxDQUM5RSxDQUFDO1NBQ0g7UUFDRCxxQ0FDRSxxQkFBcUIsRUFBRSxFQUFFLEVBQ3pCLG1CQUFtQixFQUFFLEVBQUUsRUFDdkIsVUFBVSxF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LElBQUksQ0FBQztRQUM3QixJQUFJLFNBQVMsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFO1lBQ2pDLElBQUksV0FBVyxHQUFHLFNBQVMsQ0FBQyxVQUEyQyxDQUFDO1lBQ3hFLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7U0FDakY7S0FDRjtJQUNELFVBQVUsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0FBQzVCLENBQUM7QUFFRCxTQUFTLGtCQUFrQixDQUFDLElBQWdCLEVBQUUsTUFBd0I7SUFDcEUsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSw2QkFBNkIsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO0FBQ2xGLENBQUM7QUFFRCxTQUFTLElBQUksQ0FBQyxJQUFvQztJQUNoRCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssZUFBZSxFQUFFO1FBQ2pDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztLQUNuQjtTQUFNO1FBQ0wsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0tBQ2xCO0FBQ0gsQ0FBQztBQUVELGtCQUFlLFVBQVUsQ0FBVSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE5vZGVQYXRoIH0gZnJvbSAnQGJhYmVsL3RyYXZlcnNlJztcbmltcG9ydCB0eXBlICogYXMgQmFiZWwgZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyB0eXBlcyBhcyB0IH0gZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHsgSW1wb3J0VXRpbCB9IGZyb20gJ2JhYmVsLWltcG9ydC11dGlsJztcbmltcG9ydCB7IEV4cHJlc3Npb25QYXJzZXIgfSBmcm9tICcuL2V4cHJlc3Npb24tcGFyc2VyJztcbmltcG9ydCB7IEpTVXRpbHMsIEV4dGVuZGVkUGx1Z2luQnVpbGRlciB9IGZyb20gJy4vanMtdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBFbWJlclRlbXBsYXRlQ29tcGlsZXIsIFByZXByb2Nlc3NPcHRpb25zIH0gZnJvbSAnLi9lbWJlci10ZW1wbGF0ZS1jb21waWxlcic7XG5pbXBvcnQgeyBMZWdhY3lNb2R1bGVOYW1lIH0gZnJvbSAnLi9wdWJsaWMtdHlwZXMnO1xuaW1wb3J0IHsgU2NvcGVMb2NhbHMgfSBmcm9tICcuL3Njb3BlLWxvY2Fscyc7XG5pbXBvcnQgeyBBU1RQbHVnaW5CdWlsZGVyLCBnZXRUZW1wbGF0ZUxvY2FscywgcHJlcHJvY2VzcywgcHJpbnQgfSBmcm9tICdAZ2xpbW1lci9zeW50YXgnO1xuXG5leHBvcnQgKiBmcm9tICcuL3B1YmxpYy10eXBlcyc7XG5cbnR5cGUgTW9kdWxlTmFtZSA9IExlZ2FjeU1vZHVsZU5hbWUgfCAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGF0aW9uJyB8ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsZXInO1xuXG5pbnRlcmZhY2UgTW9kdWxlQ29uZmlnIHtcbiAgbW9kdWxlTmFtZTogTW9kdWxlTmFtZTtcbiAgZXhwb3J0OiBzdHJpbmc7XG4gIGFsbG93VGVtcGxhdGVMaXRlcmFsPzogdHJ1ZTtcbiAgZW5hYmxlU2NvcGU/OiB0cnVlO1xuICByZmM5MzFTdXBwb3J0PzogJ3BvbHlmaWxsZWQnO1xufVxuXG5jb25zdCBJTkxJTkVfUFJFQ09NUElMRV9NT0RVTEVTOiBNb2R1bGVDb25maWdbXSA9IFtcbiAge1xuICAgIG1vZHVsZU5hbWU6ICdlbWJlci1jbGktaHRtbGJhcnMnLFxuICAgIGV4cG9ydDogJ2hicycsXG4gICAgYWxsb3dUZW1wbGF0ZUxpdGVyYWw6IHRydWUsXG4gIH0sXG4gIHtcbiAgICBtb2R1bGVOYW1lOiAnZW1iZXItY2xpLWh0bWxiYXJzLWlubGluZS1wcmVjb21waWxlJyxcbiAgICBleHBvcnQ6ICdkZWZhdWx0JyxcbiAgICBhbGxvd1RlbXBsYXRlTGl0ZXJhbDogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIG1vZHVsZU5hbWU6ICdodG1sYmFycy1pbmxpbmUtcHJlY29tcGlsZScsXG4gICAgZXhwb3J0OiAnZGVmYXVsdCcsXG4gICAgYWxsb3dUZW1wbGF0ZUxpdGVyYWw6IHRydWUsXG4gIH0sXG4gIHtcbiAgICBtb2R1bGVOYW1lOiAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGF0aW9uJyxcbiAgICBleHBvcnQ6ICdwcmVjb21waWxlVGVtcGxhdGUnLFxuICAgIGVuYWJsZVNjb3BlOiB0cnVlLFxuICB9LFxuICB7XG4gICAgbW9kdWxlTmFtZTogJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxlcicsXG4gICAgZXhwb3J0OiAndGVtcGxhdGUnLFxuICAgIGVuYWJsZVNjb3BlOiB0cnVlLFxuICAgIHJmYzkzMVN1cHBvcnQ6ICdwb2x5ZmlsbGVkJyxcbiAgfSxcbl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9ucyB7XG4gIC8vIFRoZSBlbWJlci10ZW1wbGF0ZS1jb21waWxlci5qcyBtb2R1bGUgdGhhdCBzaGlwcyB3aXRoaW4geW91ciBlbWJlci1zb3VyY2VcbiAgLy8gdmVyc2lvbi4gTWFuZGF0b3J5IHdoZW4gdXNpbmcgdGFyZ2V0Rm9ybWF0OiAnd2lyZScuXG4gIGNvbXBpbGVyPzogRW1iZXJUZW1wbGF0ZUNvbXBpbGVyO1xuXG4gIC8vIEFsbG93cyB5b3UgdG8gcmVtYXAgd2hhdCBpbXBvcnRzIHdpbGwgYmUgZW1pdHRlZCBpbiBvdXIgY29tcGlsZWQgb3V0cHV0LiBCeVxuICAvLyBleGFtcGxlOlxuICAvL1xuICAvLyAgIG91dHB1dE1vZHVsZU92ZXJyaWRlczoge1xuICAvLyAgICAgJ0BlbWJlci90ZW1wbGF0ZS1mYWN0b3J5Jzoge1xuICAvLyAgICAgICBjcmVhdGVUZW1wbGF0ZUZhY3Rvcnk6IFsnY3JlYXRlVGVtcGxhdGVGYWN0b3J5JywgJ0BnbGltbWVyL2NvcmUnXSxcbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vXG4gIC8vIE5vcm1hbCBFbWJlciBhcHBzIHNob3VsZG4ndCBuZWVkIHRoaXMsIGl0IGV4aXN0cyB0byBzdXBwb3J0IG90aGVyXG4gIC8vIGVudmlyb25tZW50cyBsaWtlIHN0YW5kYWxvbmUgR2xpbW1lckpTXG4gIG91dHB1dE1vZHVsZU92ZXJyaWRlcz86IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIFtzdHJpbmcsIHN0cmluZ10+PjtcblxuICAvLyBCeSBkZWZhdWx0LCB0aGlzIHBsdWdpbiBpbXBsZW1lbnRzIG9ubHkgRW1iZXIncyBzdGFibGUgcHVibGljIEFQSSBmb3JcbiAgLy8gdGVtcGxhdGUgY29tcGlsYXRpb24sIHdoaWNoIGlzOlxuICAvL1xuICAvLyAgICBpbXBvcnQgeyBwcmVjb21waWxlVGVtcGxhdGUgfSBmcm9tICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nO1xuICAvL1xuICAvLyBCdXQgaGlzdG9yaWNhbGx5IHRoZXJlIGFyZSBzZXZlcmFsIG90aGVyIGltcG9ydGFibGUgc3ludGF4ZXMgaW4gd2lkZXNwcmVhZFxuICAvLyB1c2UsIGFuZCB3ZSBjYW4gZW5hYmxlIHRob3NlIHRvbyBieSBpbmNsdWRpbmcgdGhlaXIgbW9kdWxlIG5hbWVzIGluIHRoaXNcbiAgLy8gbGlzdC5cbiAgZW5hYmxlTGVnYWN5TW9kdWxlcz86IExlZ2FjeU1vZHVsZU5hbWVbXTtcblxuICAvLyBDb250cm9scyB0aGUgb3V0cHV0IGZvcm1hdC5cbiAgLy9cbiAgLy8gIFwid2lyZVwiOiBUaGUgZGVmYXVsdC4gSW4gdGhlIG91dHB1dCwgeW91ciB0ZW1wbGF0ZXMgYXJlIHJlYWR5IHRvIGV4ZWN1dGUgaW5cbiAgLy8gIHRoZSBtb3N0IHBlcmZvcm1hbnQgd2F5LlxuICAvL1xuICAvLyAgXCJoYnNcIjogSW4gdGhlIG91dHB1dCwgeW91ciB0ZW1wbGF0ZXMgd2lsbCBzdGlsbCBiZSBpbiBIQlMgZm9ybWF0LlxuICAvLyAgR2VuZXJhbGx5IHRoaXMgbWVhbnMgdGhleSB3aWxsIHN0aWxsIG5lZWQgZnVydGhlciBwcm9jZXNzaW5nIGJlZm9yZVxuICAvLyAgdGhleSdyZSByZWFkeSB0byBleGVjdXRlLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1vZGUgaXMgdG8gc3VwcG9ydCB0aGluZ3NcbiAgLy8gIGxpa2UgY29kZW1vZHMgYW5kIHByZS1wdWJsaWNhdGlvbiB0cmFuc2Zvcm1hdGlvbnMgaW4gbGlicmFyaWVzLlxuICB0YXJnZXRGb3JtYXQ/OiAnd2lyZScgfCAnaGJzJztcblxuICAvLyBPcHRpb25hbCBsaXN0IG9mIGN1c3RvbSB0cmFuc2Zvcm1zIHRvIGFwcGx5IHRvIHRoZSBoYW5kbGViYXJzIEFTVCBiZWZvcmVcbiAgLy8gY29tcGlsYXRpb24uXG4gIHRyYW5zZm9ybXM/OiBFeHRlbmRlZFBsdWdpbkJ1aWxkZXJbXTtcbn1cblxuaW50ZXJmYWNlIFdpcmVPcHRzIHtcbiAgdGFyZ2V0Rm9ybWF0OiAnd2lyZSc7XG4gIGNvbXBpbGVyOiBFbWJlclRlbXBsYXRlQ29tcGlsZXI7XG4gIG91dHB1dE1vZHVsZU92ZXJyaWRlczogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgW3N0cmluZywgc3RyaW5nXT4+O1xuICBlbmFibGVMZWdhY3lNb2R1bGVzOiBMZWdhY3lNb2R1bGVOYW1lW107XG4gIHRyYW5zZm9ybXM6IEV4dGVuZGVkUGx1Z2luQnVpbGRlcltdO1xufVxuXG5pbnRlcmZhY2UgSGJzT3B0cyB7XG4gIHRhcmdldEZvcm1hdDogJ2hicyc7XG4gIG91dHB1dE1vZHVsZU92ZXJyaWRlczogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgW3N0cmluZywgc3RyaW5nXT4+O1xuICBlbmFibGVMZWdhY3lNb2R1bGVzOiBMZWdhY3lNb2R1bGVOYW1lW107XG4gIHRyYW5zZm9ybXM6IEV4dGVuZGVkUGx1Z2luQnVpbGRlcltdO1xufVxuXG50eXBlIE5vcm1hbGl6ZWRPcHRzID0gV2lyZU9wdHMgfCBIYnNPcHRzO1xuXG5mdW5jdGlvbiBub3JtYWxpemVPcHRzKG9wdGlvbnM6IE9wdGlvbnMpOiBOb3JtYWxpemVkT3B0cyB7XG4gIGlmICgob3B0aW9ucy50YXJnZXRGb3JtYXQgPz8gJ3dpcmUnKSA9PT0gJ3dpcmUnKSB7XG4gICAgbGV0IHsgY29tcGlsZXIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFjb21waWxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgd2hlbiB0YXJnZXRGb3JtYXQ9PT1cIndpcmVcIiB5b3UgbXVzdCBzZXQgdGhlIGNvbXBpbGVyIG9yIGNvbXBpbGVyUGF0aCBvcHRpb25gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzOiB7fSxcbiAgICAgIGVuYWJsZUxlZ2FjeU1vZHVsZXM6IFtdLFxuICAgICAgdHJhbnNmb3JtczogW10sXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdGFyZ2V0Rm9ybWF0OiAnd2lyZScsXG4gICAgICBjb21waWxlcixcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXRNb2R1bGVPdmVycmlkZXM6IHt9LFxuICAgICAgZW5hYmxlTGVnYWN5TW9kdWxlczogW10sXG4gICAgICB0cmFuc2Zvcm1zOiBbXSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0YXJnZXRGb3JtYXQ6ICdoYnMnLFxuICAgIH07XG4gIH1cbn1cblxuaW50ZXJmYWNlIFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4ge1xuICBvcHRzOiBFbnZTcGVjaWZpY09wdGlvbnM7XG4gIG5vcm1hbGl6ZWRPcHRzOiBOb3JtYWxpemVkT3B0cztcbiAgdXRpbDogSW1wb3J0VXRpbDtcbiAgdGVtcGxhdGVGYWN0b3J5OiB7IG1vZHVsZU5hbWU6IHN0cmluZzsgZXhwb3J0TmFtZTogc3RyaW5nIH07XG4gIHByb2dyYW06IE5vZGVQYXRoPHQuUHJvZ3JhbT47XG4gIGxhc3RJbnNlcnRlZFBhdGg6IE5vZGVQYXRoPHQuU3RhdGVtZW50PiB8IHVuZGVmaW5lZDtcbiAgZmlsZW5hbWU6IHN0cmluZztcbiAgcmVjdXJzaW9uR3VhcmQ6IFNldDx1bmtub3duPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQbHVnaW48RW52U3BlY2lmaWNPcHRpb25zPihsb2FkT3B0aW9uczogKG9wdHM6IEVudlNwZWNpZmljT3B0aW9ucykgPT4gT3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gaHRtbGJhcnNJbmxpbmVQcmVjb21waWxlKFxuICAgIGJhYmVsOiB0eXBlb2YgQmFiZWxcbiAgKTogQmFiZWwuUGx1Z2luT2JqPFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4+IHtcbiAgICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZpc2l0b3I6IHtcbiAgICAgICAgUHJvZ3JhbToge1xuICAgICAgICAgIGVudGVyKHBhdGg6IE5vZGVQYXRoPHQuUHJvZ3JhbT4sIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+KSB7XG4gICAgICAgICAgICBzdGF0ZS5ub3JtYWxpemVkT3B0cyA9IG5vcm1hbGl6ZU9wdHMobG9hZE9wdGlvbnMoc3RhdGUub3B0cykpO1xuICAgICAgICAgICAgc3RhdGUudGVtcGxhdGVGYWN0b3J5ID0gdGVtcGxhdGVGYWN0b3J5Q29uZmlnKHN0YXRlLm5vcm1hbGl6ZWRPcHRzKTtcbiAgICAgICAgICAgIHN0YXRlLnV0aWwgPSBuZXcgSW1wb3J0VXRpbCh0LCBwYXRoKTtcbiAgICAgICAgICAgIHN0YXRlLnByb2dyYW0gPSBwYXRoO1xuICAgICAgICAgICAgc3RhdGUucmVjdXJzaW9uR3VhcmQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBleGl0KF9wYXRoOiBOb2RlUGF0aDx0LlByb2dyYW0+LCBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPikge1xuICAgICAgICAgICAgaWYgKHN0YXRlLm5vcm1hbGl6ZWRPcHRzLnRhcmdldEZvcm1hdCA9PT0gJ3dpcmUnKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IHsgbW9kdWxlTmFtZSwgZXhwb3J0OiBleHBvcnROYW1lIH0gb2YgY29uZmlndXJlZE1vZHVsZXMoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudXRpbC5yZW1vdmVJbXBvcnQobW9kdWxlTmFtZSwgZXhwb3J0TmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihcbiAgICAgICAgICBwYXRoOiBOb2RlUGF0aDx0LlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbj4sXG4gICAgICAgICAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz5cbiAgICAgICAgKSB7XG4gICAgICAgICAgbGV0IHRhZ1BhdGggPSBwYXRoLmdldCgndGFnJyk7XG5cbiAgICAgICAgICBpZiAoIXRhZ1BhdGguaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHJlZmVyZW5jZXNJbmxpbmVDb21waWxlcih0YWdQYXRoLCBzdGF0ZSk7XG4gICAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWNvbmZpZy5hbGxvd1RlbXBsYXRlTGl0ZXJhbCkge1xuICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHVzZSBcXGAke3RhZ1BhdGgubm9kZS5uYW1lfVxcYCBhcyBhIHRlbXBsYXRlIHRhZywgYnV0IGl0IGNhbiBvbmx5IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uIHdpdGggYSBzdHJpbmcgcGFzc2VkIHRvIGl0OiAke3RhZ1BhdGgubm9kZS5uYW1lfSgnY29udGVudCBoZXJlJylgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXRoLm5vZGUucXVhc2kuZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgICdwbGFjZWhvbGRlcnMgaW5zaWRlIGEgdGFnZ2VkIHRlbXBsYXRlIHN0cmluZyBhcmUgbm90IHN1cHBvcnRlZCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHRlbXBsYXRlID0gcGF0aC5ub2RlLnF1YXNpLnF1YXNpcy5tYXAoKHF1YXNpKSA9PiBxdWFzaS52YWx1ZS5jb29rZWQpLmpvaW4oJycpO1xuICAgICAgICAgIGlmIChzdGF0ZS5ub3JtYWxpemVkT3B0cy50YXJnZXRGb3JtYXQgPT09ICd3aXJlJykge1xuICAgICAgICAgICAgaW5zZXJ0Q29tcGlsZWRUZW1wbGF0ZShcbiAgICAgICAgICAgICAgYmFiZWwsXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICBzdGF0ZS5ub3JtYWxpemVkT3B0cyxcbiAgICAgICAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5zZXJ0VHJhbnNmb3JtZWRUZW1wbGF0ZShiYWJlbCwgc3RhdGUsIHRlbXBsYXRlLCBwYXRoLCB7fSwgY29uZmlnLCB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBDYWxsRXhwcmVzc2lvbihwYXRoOiBOb2RlUGF0aDx0LkNhbGxFeHByZXNzaW9uPiwgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4pIHtcbiAgICAgICAgICBsZXQgY2FsbGVlUGF0aCA9IHBhdGguZ2V0KCdjYWxsZWUnKTtcblxuICAgICAgICAgIGlmICghY2FsbGVlUGF0aC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY29uZmlnID0gcmVmZXJlbmNlc0lubGluZUNvbXBpbGVyKGNhbGxlZVBhdGgsIHN0YXRlKTtcbiAgICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZS5yZWN1cnNpb25HdWFyZC5oYXMocGF0aC5ub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXRoLmdldCgnYXJndW1lbnRzJykubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICBgJHtjYWxsZWVQYXRoLm5vZGUubmFtZX0gY2FuIG9ubHkgYmUgaW52b2tlZCB3aXRoIDIgYXJndW1lbnRzOiB0aGUgdGVtcGxhdGUgc3RyaW5nIGFuZCBhbnkgc3RhdGljIG9wdGlvbnNgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBbZmlyc3RBcmcsIHNlY29uZEFyZ10gPSBwYXRoLmdldCgnYXJndW1lbnRzJyk7XG5cbiAgICAgICAgICBsZXQgdGVtcGxhdGU7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpcnN0QXJnPy5ub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1N0cmluZ0xpdGVyYWwnOlxuICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IGZpcnN0QXJnLm5vZGUudmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVGVtcGxhdGVMaXRlcmFsJzpcbiAgICAgICAgICAgICAgaWYgKGZpcnN0QXJnLm5vZGUuZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAgICAgJ3BsYWNlaG9sZGVycyBpbnNpZGUgYSB0ZW1wbGF0ZSBzdHJpbmcgYXJlIG5vdCBzdXBwb3J0ZWQnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IGZpcnN0QXJnLm5vZGUucXVhc2lzLm1hcCgocXVhc2kpID0+IHF1YXNpLnZhbHVlLmNvb2tlZCkuam9pbignJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgYHRhZ2dlZCB0ZW1wbGF0ZSBzdHJpbmdzIGluc2lkZSAke2NhbGxlZVBhdGgubm9kZS5uYW1lfSBhcmUgbm90IHN1cHBvcnRlZGBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgICBgJHtjYWxsZWVQYXRoLm5vZGUubmFtZX0gc2hvdWxkIGJlIGludm9rZWQgd2l0aCBhdCBsZWFzdCBhIHNpbmdsZSBhcmd1bWVudCAodGhlIHRlbXBsYXRlIHN0cmluZylgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgICAgIGxldCBiYWNraW5nQ2xhc3M6IHVuZGVmaW5lZCB8IE5vZGVQYXRoPFBhcmFtZXRlcnM8dHlwZW9mIHQuY2FsbEV4cHJlc3Npb24+WzFdW251bWJlcl0+O1xuXG4gICAgICAgICAgaWYgKCFzZWNvbmRBcmcpIHtcbiAgICAgICAgICAgIHVzZXJUeXBlZE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzZWNvbmRBcmcuaXNPYmplY3RFeHByZXNzaW9uKCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAgIGAke2NhbGxlZVBhdGgubm9kZS5uYW1lfSBjYW4gb25seSBiZSBpbnZva2VkIHdpdGggMiBhcmd1bWVudHM6IHRoZSB0ZW1wbGF0ZSBzdHJpbmcsIGFuZCBhbnkgc3RhdGljIG9wdGlvbnNgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVzZXJUeXBlZE9wdGlvbnMgPSBuZXcgRXhwcmVzc2lvblBhcnNlcihiYWJlbCkucGFyc2VPYmplY3RFeHByZXNzaW9uKFxuICAgICAgICAgICAgICBjYWxsZWVQYXRoLm5vZGUubmFtZSxcbiAgICAgICAgICAgICAgc2Vjb25kQXJnLFxuICAgICAgICAgICAgICBjb25maWcuZW5hYmxlU2NvcGUsXG4gICAgICAgICAgICAgIEJvb2xlYW4oY29uZmlnLnJmYzkzMVN1cHBvcnQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5yZmM5MzFTdXBwb3J0ICYmIHVzZXJUeXBlZE9wdGlvbnMuY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIGJhY2tpbmdDbGFzcyA9IHVzZXJUeXBlZE9wdGlvbnMuY29tcG9uZW50IGFzIE5vZGVQYXRoPFxuICAgICAgICAgICAgICAgIFBhcmFtZXRlcnM8dHlwZW9mIHQuY2FsbEV4cHJlc3Npb24+WzFdW251bWJlcl1cbiAgICAgICAgICAgICAgPjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUubm9ybWFsaXplZE9wdHMudGFyZ2V0Rm9ybWF0ID09PSAnd2lyZScpIHtcbiAgICAgICAgICAgIGluc2VydENvbXBpbGVkVGVtcGxhdGUoXG4gICAgICAgICAgICAgIGJhYmVsLFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgc3RhdGUubm9ybWFsaXplZE9wdHMsXG4gICAgICAgICAgICAgIHRlbXBsYXRlLFxuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICB1c2VyVHlwZWRPcHRpb25zLFxuICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgIGJhY2tpbmdDbGFzc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5zZXJ0VHJhbnNmb3JtZWRUZW1wbGF0ZShcbiAgICAgICAgICAgICAgYmFiZWwsXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgdXNlclR5cGVkT3B0aW9ucyxcbiAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICBiYWNraW5nQ2xhc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB9IGFzIChiYWJlbDogdHlwZW9mIEJhYmVsKSA9PiBCYWJlbC5QbHVnaW5PYmo8dW5rbm93bj47XG59XG5cbmZ1bmN0aW9uKiBjb25maWd1cmVkTW9kdWxlczxFbnZTcGVjaWZpY09wdGlvbnM+KHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+KSB7XG4gIGZvciAobGV0IG1vZHVsZUNvbmZpZyBvZiBJTkxJTkVfUFJFQ09NUElMRV9NT0RVTEVTKSB7XG4gICAgaWYgKFxuICAgICAgbW9kdWxlQ29uZmlnLm1vZHVsZU5hbWUgIT09ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nICYmXG4gICAgICBtb2R1bGVDb25maWcubW9kdWxlTmFtZSAhPT0gJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxlcicgJiZcbiAgICAgICFzdGF0ZS5ub3JtYWxpemVkT3B0cy5lbmFibGVMZWdhY3lNb2R1bGVzLmluY2x1ZGVzKG1vZHVsZUNvbmZpZy5tb2R1bGVOYW1lKVxuICAgICkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHlpZWxkIG1vZHVsZUNvbmZpZztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWZlcmVuY2VzSW5saW5lQ29tcGlsZXI8RW52U3BlY2lmaWNPcHRpb25zPihcbiAgcGF0aDogTm9kZVBhdGg8dC5JZGVudGlmaWVyPixcbiAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz5cbik6IE1vZHVsZUNvbmZpZyB8IHVuZGVmaW5lZCB7XG4gIGZvciAobGV0IG1vZHVsZUNvbmZpZyBvZiBjb25maWd1cmVkTW9kdWxlcyhzdGF0ZSkpIHtcbiAgICBpZiAocGF0aC5yZWZlcmVuY2VzSW1wb3J0KG1vZHVsZUNvbmZpZy5tb2R1bGVOYW1lLCBtb2R1bGVDb25maWcuZXhwb3J0KSkge1xuICAgICAgcmV0dXJuIG1vZHVsZUNvbmZpZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcnVudGltZUVycm9ySUlGRShiYWJlbDogdHlwZW9mIEJhYmVsLCByZXBsYWNlbWVudHM6IHsgRVJST1JfTUVTU0FHRTogc3RyaW5nIH0pIHtcbiAgbGV0IHN0YXRlbWVudCA9IGJhYmVsLnRlbXBsYXRlKGAoZnVuY3Rpb24oKSB7XFxuICB0aHJvdyBuZXcgRXJyb3IoJ0VSUk9SX01FU1NBR0UnKTtcXG59KSgpO2ApKFxuICAgIHJlcGxhY2VtZW50c1xuICApIGFzIHQuRXhwcmVzc2lvblN0YXRlbWVudDtcbiAgcmV0dXJuIHN0YXRlbWVudC5leHByZXNzaW9uO1xufVxuXG5mdW5jdGlvbiBidWlsZFNjb3BlTG9jYWxzKFxuICB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgZm9ybWF0T3B0aW9uczogTW9kdWxlQ29uZmlnLFxuICB0ZW1wbGF0ZUNvbnRlbnQ6IHN0cmluZ1xuKTogU2NvcGVMb2NhbHMge1xuICBpZiAoZm9ybWF0T3B0aW9ucy5yZmM5MzFTdXBwb3J0ICYmIHVzZXJUeXBlZE9wdGlvbnMuZXZhbCkge1xuICAgIHJldHVybiBkaXNjb3ZlckxvY2Fscyh0ZW1wbGF0ZUNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHVzZXJUeXBlZE9wdGlvbnMuc2NvcGUpIHtcbiAgICByZXR1cm4gdXNlclR5cGVkT3B0aW9ucy5zY29wZSBhcyBTY29wZUxvY2FscztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFNjb3BlTG9jYWxzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzY292ZXJMb2NhbHModGVtcGxhdGVDb250ZW50OiBzdHJpbmcpOiBTY29wZUxvY2FscyB7XG4gIC8vIHRoaXMgaXMgd3JvbmcsIGJ1dCB0aGUgcmlnaHQgdGhpbmcgaXMgdW5yZWxlYXNlZCBpblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2xpbW1lcmpzL2dsaW1tZXItdm0vcHVsbC8xNDIxLCBzbyBmb3IgdGhlIG1vbWVudCBJJ21cbiAgLy8gc3RpY2tpbmcgd2l0aCB0aGUgZXhhY3QgYmVoYXZpb3IgdGhhdCBlbWJlci10ZW1wbGF0ZXMtaW1wb3J0cyBoYXMuXG4gIC8vXG4gIC8vICh0aGUgcmVhc29uIGl0J3Mgd3JvbmcgaXMgdGhhdCB0aGUgY29ycmVjdCBhbnN3ZXIgZGVwZW5kcyBvbiBub3QganVzdCB0aGVcbiAgLy8gdGVtcGxhdGUsIGJ1dCB0aGUgYW1iaWVudCBqYXZhc2NyaXB0IHNjb3BlLiBBbnl0aGluZyBpbiBsb2NhbHMgbmVlZHMgdG8gd2luXG4gIC8vIG92ZXIgZW1iZXIga2V5d29yZHMuIE90aGVyd2lzZSB3ZSBjYW4gbmV2ZXIgaW50cm9kdWNlIG5ldyBrZXl3b3Jkcy4pXG4gIGxldCBzY29wZUxvY2FscyA9IG5ldyBTY29wZUxvY2FscygpO1xuICBmb3IgKGxldCBsb2NhbCBvZiBnZXRUZW1wbGF0ZUxvY2Fscyh0ZW1wbGF0ZUNvbnRlbnQpKSB7XG4gICAgaWYgKGxvY2FsLm1hdGNoKC9eWyRBLVpfXVswLTlBLVpfJF0qJC9pKSkge1xuICAgICAgc2NvcGVMb2NhbHMuYWRkKGxvY2FsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjb3BlTG9jYWxzO1xufVxuXG5mdW5jdGlvbiBidWlsZFByZWNvbXBpbGVPcHRpb25zPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gIGJhYmVsOiB0eXBlb2YgQmFiZWwsXG4gIHRhcmdldDogTm9kZVBhdGg8dC5FeHByZXNzaW9uPixcbiAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4sXG4gIHRlbXBsYXRlOiBzdHJpbmcsXG4gIHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBjb25maWc6IE1vZHVsZUNvbmZpZyxcbiAgc2NvcGU6IFNjb3BlTG9jYWxzXG4pOiBQcmVwcm9jZXNzT3B0aW9ucyAmIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgbGV0IGpzdXRpbHMgPSBuZXcgSlNVdGlscyhiYWJlbCwgc3RhdGUsIHRhcmdldCwgc2NvcGUsIHN0YXRlLnV0aWwpO1xuICBsZXQgbWV0YSA9IE9iamVjdC5hc3NpZ24oeyBqc3V0aWxzIH0sIHVzZXJUeXBlZE9wdGlvbnM/Lm1ldGEpO1xuXG4gIGxldCBvdXRwdXQ6IFByZXByb2Nlc3NPcHRpb25zICYgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7XG4gICAgY29udGVudHM6IHRlbXBsYXRlLFxuXG4gICAgLy8gd2UndmUgZXh0ZW5kZWQgbWV0YSB0byBhZGQganN1dGlscywgYnV0IHRoZSB0eXBlcyBpbiBAZ2xpbW1lci9zeW50YXhcbiAgICAvLyBkb24ndCBhY2NvdW50IGZvciBleHRlbnNpb25cbiAgICBtZXRhOiBtZXRhIGFzIFByZXByb2Nlc3NPcHRpb25zWydtZXRhJ10sXG5cbiAgICAvLyBUT0RPOiBlbWJyb2lkZXIncyB0ZW1wbGF0ZS1jb21waWxlciBhbGxvd3MgdGhpcyB0byBiZSBvdmVycmlkZW4gdG8gZ2V0XG4gICAgLy8gYmFja3dhcmQtY29tcGF0aWJsZSBtb2R1bGUgbmFtZXMgdGhhdCBkb24ndCBtYXRjaCB0aGUgcmVhbCBuYW1lIG9mIHRoZVxuICAgIC8vIG9uLWRpc2sgZmlsZS4gV2hhdCdzIG91ciBwbGFuIGZvciBtaWdyYXRpbmcgcGVvcGxlIGF3YXkgZnJvbSB0aGF0P1xuICAgIG1vZHVsZU5hbWU6IHN0YXRlLmZpbGVuYW1lLFxuXG4gICAgLy8gVGhpcyBpcyBoZXJlIHNvIGl0J3MgKmFsd2F5cyogdGhlIHJlYWwgZmlsZW5hbWUuIEhpc3RvcmljYWxseSwgdGhlcmUgaXNcbiAgICAvLyBhbHNvIGBtb2R1bGVOYW1lYCBidXQgdGhhdCBkaWQgbm90IG1hdGNoIHRoZSByZWFsIG9uLWRpc2sgZmlsZW5hbWUsIGl0XG4gICAgLy8gd2FzIHRoZSBub3Rpb25hbCBydW50aW1lIG1vZHVsZSBuYW1lIGZyb20gY2xhc3NpYyBlbWJlciBidWlsZHMuXG4gICAgZmlsZW5hbWU6IHN0YXRlLmZpbGVuYW1lLFxuXG4gICAgcGx1Z2luczoge1xuICAgICAgLy8gdGhlIGNhc3QgaXMgbmVlZGVkIGhlcmUgb25seSBiZWNhdXNlIG91ciBtZXRhIGlzIGV4dGVuZGVkLiBUaGF0IGlzLFxuICAgICAgLy8gdGhlc2UgcGx1Z2lucyBjYW4gYWNjZXNzIG1ldGEuanN1dGlscy5cbiAgICAgIGFzdDogc3RhdGUubm9ybWFsaXplZE9wdHMudHJhbnNmb3JtcyBhcyBBU1RQbHVnaW5CdWlsZGVyW10sXG4gICAgfSxcbiAgfTtcblxuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModXNlclR5cGVkT3B0aW9ucykpIHtcbiAgICBpZiAoa2V5ICE9PSAnc2NvcGUnKSB7XG4gICAgICAvLyBgc2NvcGVgIGluIHRoZSB1c2VyLWZhY2luZyBBUEkgYmVjb21lcyBgbG9jYWxzYCBpbiB0aGUgbG93LWxldmVsXG4gICAgICAvLyBlbWJlci10ZW1wbGF0ZS1jb21waWxlciBBUElcbiAgICAgIG91dHB1dFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgb3V0cHV0LmxvY2FscyA9IHNjb3BlLmxvY2FscztcblxuICBpZiAoY29uZmlnLnJmYzkzMVN1cHBvcnQpIHtcbiAgICBvdXRwdXQuc3RyaWN0TW9kZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBpZiBzY29wZSBoYXMgZGlmZmVyZW50IGtleXMgYW5kIHZhbHVlcywgdGhpcyBmdW5jdGlvbiB3aWxsIHJlbWFwIHRoZSBrZXlzIHRvIHRoZSB2YWx1ZXNcbi8vIHlvdSBjYW4gc2VlIGFuIGV4YW1wbGUgb2YgdGhpcyBpbiB0aGUgdGVzdCBcImNvcnJlY3RseSBoYW5kbGVzIHNjb3BlIGlmIGl0IGNvbnRhaW5zIGtleXMgYW5kIHZhbHVlc1wiXG5mdW5jdGlvbiByZW1hcElkZW50aWZpZXJzKGFzdDogQmFiZWwudHlwZXMuRmlsZSwgYmFiZWw6IHR5cGVvZiBCYWJlbCwgc2NvcGVMb2NhbHM6IFNjb3BlTG9jYWxzKSB7XG4gIGlmICghc2NvcGVMb2NhbHMubmVlZHNSZW1hcHBpbmcoKSkge1xuICAgIC8vIGRvIG5vdGhpbmcgaWYgYWxsIGtleXMgYXJlIHRoZSBzYW1lIGFzIHRoZWlyIHZhbHVlc1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGJhYmVsLnRyYXZlcnNlKGFzdCwge1xuICAgIElkZW50aWZpZXIocGF0aDogTm9kZVBhdGg8dC5JZGVudGlmaWVyPikge1xuICAgICAgaWYgKHNjb3BlTG9jYWxzLmhhcyhwYXRoLm5vZGUubmFtZSkgJiYgcGF0aC5ub2RlLm5hbWUgIT09IHNjb3BlTG9jYWxzLmdldChwYXRoLm5vZGUubmFtZSkpIHtcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgcGF0aCBvbmx5IGlmIHRoZSBrZXkgaXMgZGlmZmVyZW50IGZyb20gdGhlIHZhbHVlXG4gICAgICAgIHBhdGgucmVwbGFjZVdpdGgoYmFiZWwudHlwZXMuaWRlbnRpZmllcihzY29wZUxvY2Fscy5nZXQocGF0aC5ub2RlLm5hbWUpKSk7XG4gICAgICB9XG4gICAgfSxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydENvbXBpbGVkVGVtcGxhdGU8RW52U3BlY2lmaWNPcHRpb25zPihcbiAgYmFiZWw6IHR5cGVvZiBCYWJlbCxcbiAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4sXG4gIG9wdHM6IFdpcmVPcHRzLFxuICB0ZW1wbGF0ZTogc3RyaW5nLFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuRXhwcmVzc2lvbj4sXG4gIHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBjb25maWc6IE1vZHVsZUNvbmZpZyxcbiAgYmFja2luZ0NsYXNzOiBOb2RlUGF0aDxQYXJhbWV0ZXJzPHR5cGVvZiB0LmNhbGxFeHByZXNzaW9uPlsxXVtudW1iZXJdPiB8IHVuZGVmaW5lZFxuKSB7XG4gIGxldCB0ID0gYmFiZWwudHlwZXM7XG4gIGxldCBzY29wZUxvY2FscyA9IGJ1aWxkU2NvcGVMb2NhbHModXNlclR5cGVkT3B0aW9ucywgY29uZmlnLCB0ZW1wbGF0ZSk7XG4gIGxldCBvcHRpb25zID0gYnVpbGRQcmVjb21waWxlT3B0aW9ucyhcbiAgICBiYWJlbCxcbiAgICB0YXJnZXQsXG4gICAgc3RhdGUsXG4gICAgdGVtcGxhdGUsXG4gICAgdXNlclR5cGVkT3B0aW9ucyxcbiAgICBjb25maWcsXG4gICAgc2NvcGVMb2NhbHNcbiAgKTtcblxuICBsZXQgcHJlY29tcGlsZVJlc3VsdFN0cmluZzogc3RyaW5nO1xuXG4gIC8vIGluc2VydFJ1bnRpbWVFcnJvcnMgaXMgbGVnYWN5IGFuZCBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBuZXdlciByZmM5MzEgZm9ybVxuICBpZiAob3B0aW9ucy5pbnNlcnRSdW50aW1lRXJyb3JzICYmICFjb25maWcucmZjOTMxU3VwcG9ydCkge1xuICAgIHRyeSB7XG4gICAgICBwcmVjb21waWxlUmVzdWx0U3RyaW5nID0gb3B0cy5jb21waWxlci5wcmVjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGFyZ2V0LnJlcGxhY2VXaXRoKHJ1bnRpbWVFcnJvcklJRkUoYmFiZWwsIHsgRVJST1JfTUVTU0FHRTogKGVycm9yIGFzIGFueSkubWVzc2FnZSB9KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHByZWNvbXBpbGVSZXN1bHRTdHJpbmcgPSBvcHRzLmNvbXBpbGVyLnByZWNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgbGV0IHByZWNvbXBpbGVSZXN1bHRBU1QgPSBiYWJlbC5wYXJzZShgdmFyIHByZWNvbXBpbGVSZXN1bHQgPSAke3ByZWNvbXBpbGVSZXN1bHRTdHJpbmd9OyBgLCB7XG4gICAgYmFiZWxyYzogZmFsc2UsXG4gICAgY29uZmlnRmlsZTogZmFsc2UsXG4gIH0pIGFzIHQuRmlsZTtcblxuICByZW1hcElkZW50aWZpZXJzKHByZWNvbXBpbGVSZXN1bHRBU1QsIGJhYmVsLCBzY29wZUxvY2Fscyk7XG5cbiAgbGV0IHRlbXBsYXRlRXhwcmVzc2lvbiA9IChwcmVjb21waWxlUmVzdWx0QVNULnByb2dyYW0uYm9keVswXSBhcyB0LlZhcmlhYmxlRGVjbGFyYXRpb24pXG4gICAgLmRlY2xhcmF0aW9uc1swXS5pbml0IGFzIHQuRXhwcmVzc2lvbjtcblxuICB0LmFkZENvbW1lbnQoXG4gICAgdGVtcGxhdGVFeHByZXNzaW9uLFxuICAgICdsZWFkaW5nJyxcbiAgICBgXFxuICAke3RlbXBsYXRlLnJlcGxhY2UoL1xcKlxcLy9nLCAnKlxcXFwvJyl9XFxuYCxcbiAgICAvKiBsaW5lIGNvbW1lbnQ/ICovIGZhbHNlXG4gICk7XG5cbiAgbGV0IHRlbXBsYXRlRmFjdG9yeUlkZW50aWZpZXIgPSBzdGF0ZS51dGlsLmltcG9ydChcbiAgICB0YXJnZXQsXG4gICAgc3RhdGUudGVtcGxhdGVGYWN0b3J5Lm1vZHVsZU5hbWUsXG4gICAgc3RhdGUudGVtcGxhdGVGYWN0b3J5LmV4cG9ydE5hbWVcbiAgKTtcblxuICBsZXQgZXhwcmVzc2lvbiA9IHQuY2FsbEV4cHJlc3Npb24odGVtcGxhdGVGYWN0b3J5SWRlbnRpZmllciwgW3RlbXBsYXRlRXhwcmVzc2lvbl0pO1xuXG4gIGlmIChjb25maWcucmZjOTMxU3VwcG9ydCkge1xuICAgIGV4cHJlc3Npb24gPSB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgc3RhdGUudXRpbC5pbXBvcnQodGFyZ2V0LCAnQGVtYmVyL2NvbXBvbmVudCcsICdzZXRDb21wb25lbnRUZW1wbGF0ZScpLFxuICAgICAgW1xuICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICBiYWNraW5nQ2xhc3M/Lm5vZGUgPz9cbiAgICAgICAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgICAgc3RhdGUudXRpbC5pbXBvcnQodGFyZ2V0LCAnQGVtYmVyL2NvbXBvbmVudC90ZW1wbGF0ZS1vbmx5JywgJ2RlZmF1bHQnLCAndGVtcGxhdGVPbmx5JyksXG4gICAgICAgICAgICBbXVxuICAgICAgICAgICksXG4gICAgICBdXG4gICAgKTtcbiAgfVxuICB0YXJnZXQucmVwbGFjZVdpdGgoZXhwcmVzc2lvbik7XG59XG5cbmZ1bmN0aW9uIGluc2VydFRyYW5zZm9ybWVkVGVtcGxhdGU8RW52U3BlY2lmaWNPcHRpb25zPihcbiAgYmFiZWw6IHR5cGVvZiBCYWJlbCxcbiAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4sXG4gIHRlbXBsYXRlOiBzdHJpbmcsXG4gIHRhcmdldDogTm9kZVBhdGg8dC5DYWxsRXhwcmVzc2lvbj4gfCBOb2RlUGF0aDx0LlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbj4sXG4gIHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBmb3JtYXRPcHRpb25zOiBNb2R1bGVDb25maWcsXG4gIGJhY2tpbmdDbGFzczogTm9kZVBhdGg8UGFyYW1ldGVyczx0eXBlb2YgdC5jYWxsRXhwcmVzc2lvbj5bMV1bbnVtYmVyXT4gfCB1bmRlZmluZWRcbikge1xuICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuICBsZXQgc2NvcGVMb2NhbHMgPSBidWlsZFNjb3BlTG9jYWxzKHVzZXJUeXBlZE9wdGlvbnMsIGZvcm1hdE9wdGlvbnMsIHRlbXBsYXRlKTtcbiAgbGV0IG9wdGlvbnMgPSBidWlsZFByZWNvbXBpbGVPcHRpb25zKFxuICAgIGJhYmVsLFxuICAgIHRhcmdldCxcbiAgICBzdGF0ZSxcbiAgICB0ZW1wbGF0ZSxcbiAgICB1c2VyVHlwZWRPcHRpb25zLFxuICAgIGZvcm1hdE9wdGlvbnMsXG4gICAgc2NvcGVMb2NhbHNcbiAgKTtcbiAgbGV0IGFzdCA9IHByZXByb2Nlc3ModGVtcGxhdGUsIHsgLi4ub3B0aW9ucywgbW9kZTogJ2NvZGVtb2QnIH0pO1xuICBsZXQgdHJhbnNmb3JtZWQgPSBwcmludChhc3QsIHsgZW50aXR5RW5jb2Rpbmc6ICdyYXcnIH0pO1xuICBpZiAodGFyZ2V0LmlzQ2FsbEV4cHJlc3Npb24oKSkge1xuICAgICh0YXJnZXQuZ2V0KCdhcmd1bWVudHMuMCcpIGFzIE5vZGVQYXRoPHQuTm9kZT4pLnJlcGxhY2VXaXRoKHQuc3RyaW5nTGl0ZXJhbCh0cmFuc2Zvcm1lZCkpO1xuICAgIGlmICghc2NvcGVMb2NhbHMuaXNFbXB0eSgpKSB7XG4gICAgICBpZiAoIWZvcm1hdE9wdGlvbnMuZW5hYmxlU2NvcGUpIHtcbiAgICAgICAgbWF5YmVQcnVuZUltcG9ydChzdGF0ZS51dGlsLCB0YXJnZXQuZ2V0KCdjYWxsZWUnKSk7XG4gICAgICAgIHRhcmdldC5zZXQoJ2NhbGxlZScsIHByZWNvbXBpbGVUZW1wbGF0ZShzdGF0ZS51dGlsLCB0YXJnZXQpKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZVNjb3BlKGJhYmVsLCB0YXJnZXQsIHNjb3BlTG9jYWxzKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0T3B0aW9ucy5yZmM5MzFTdXBwb3J0ID09PSAncG9seWZpbGxlZCcpIHtcbiAgICAgIG1heWJlUHJ1bmVJbXBvcnQoc3RhdGUudXRpbCwgdGFyZ2V0LmdldCgnY2FsbGVlJykpO1xuICAgICAgdGFyZ2V0LnNldCgnY2FsbGVlJywgcHJlY29tcGlsZVRlbXBsYXRlKHN0YXRlLnV0aWwsIHRhcmdldCkpO1xuICAgICAgY29udmVydFN0cmljdE1vZGUoYmFiZWwsIHRhcmdldCk7XG4gICAgICByZW1vdmVFdmFsQW5kU2NvcGUodGFyZ2V0KTtcbiAgICAgIHRhcmdldC5ub2RlLmFyZ3VtZW50cyA9IHRhcmdldC5ub2RlLmFyZ3VtZW50cy5zbGljZSgwLCAyKTtcbiAgICAgIHN0YXRlLnJlY3Vyc2lvbkd1YXJkLmFkZCh0YXJnZXQubm9kZSk7XG4gICAgICB0YXJnZXQucmVwbGFjZVdpdGgoXG4gICAgICAgIHQuY2FsbEV4cHJlc3Npb24oc3RhdGUudXRpbC5pbXBvcnQodGFyZ2V0LCAnQGVtYmVyL2NvbXBvbmVudCcsICdzZXRDb21wb25lbnRUZW1wbGF0ZScpLCBbXG4gICAgICAgICAgdGFyZ2V0Lm5vZGUsXG4gICAgICAgICAgYmFja2luZ0NsYXNzPy5ub2RlID8/XG4gICAgICAgICAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgICAgICBzdGF0ZS51dGlsLmltcG9ydChcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgJ0BlbWJlci9jb21wb25lbnQvdGVtcGxhdGUtb25seScsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHQnLFxuICAgICAgICAgICAgICAgICd0ZW1wbGF0ZU9ubHknXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICApLFxuICAgICAgICBdKVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFzY29wZUxvY2Fscy5pc0VtcHR5KCkpIHtcbiAgICAgIC8vIG5lZWQgdG8gYWRkIHNjb3BlLCBzbyBuZWVkIHRvIHJlcGxhY2UgdGhlIGJhY2t0aWNrcyBmb3JtIHdpdGggYSBjYWxsXG4gICAgICAvLyBleHByZXNzaW9uIHRvIHByZWNvbXBpbGVUZW1wbGF0ZVxuICAgICAgbWF5YmVQcnVuZUltcG9ydChzdGF0ZS51dGlsLCB0YXJnZXQuZ2V0KCd0YWcnKSk7XG4gICAgICBsZXQgbmV3Q2FsbCA9IHRhcmdldC5yZXBsYWNlV2l0aChcbiAgICAgICAgdC5jYWxsRXhwcmVzc2lvbihwcmVjb21waWxlVGVtcGxhdGUoc3RhdGUudXRpbCwgdGFyZ2V0KSwgW3Quc3RyaW5nTGl0ZXJhbCh0cmFuc2Zvcm1lZCldKVxuICAgICAgKVswXTtcbiAgICAgIHVwZGF0ZVNjb3BlKGJhYmVsLCBuZXdDYWxsLCBzY29wZUxvY2Fscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICh0YXJnZXQuZ2V0KCdxdWFzaScpLmdldCgncXVhc2lzLjAnKSBhcyBOb2RlUGF0aDx0LlRlbXBsYXRlRWxlbWVudD4pLnJlcGxhY2VXaXRoKFxuICAgICAgICB0LnRlbXBsYXRlRWxlbWVudCh7IHJhdzogdHJhbnNmb3JtZWQgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlRmFjdG9yeUNvbmZpZyhvcHRzOiBOb3JtYWxpemVkT3B0cykge1xuICBsZXQgbW9kdWxlTmFtZSA9ICdAZW1iZXIvdGVtcGxhdGUtZmFjdG9yeSc7XG4gIGxldCBleHBvcnROYW1lID0gJ2NyZWF0ZVRlbXBsYXRlRmFjdG9yeSc7XG4gIGxldCBvdmVycmlkZXMgPSBvcHRzLm91dHB1dE1vZHVsZU92ZXJyaWRlc1ttb2R1bGVOYW1lXT8uW2V4cG9ydE5hbWVdO1xuICByZXR1cm4gb3ZlcnJpZGVzXG4gICAgPyB7IGV4cG9ydE5hbWU6IG92ZXJyaWRlc1swXSwgbW9kdWxlTmFtZTogb3ZlcnJpZGVzWzFdIH1cbiAgICA6IHsgZXhwb3J0TmFtZSwgbW9kdWxlTmFtZSB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFNjb3BlKGJhYmVsOiB0eXBlb2YgQmFiZWwsIGxvY2FsczogU2NvcGVMb2NhbHMpIHtcbiAgbGV0IHQgPSBiYWJlbC50eXBlcztcbiAgcmV0dXJuIHQuYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oXG4gICAgW10sXG4gICAgdC5vYmplY3RFeHByZXNzaW9uKFxuICAgICAgbG9jYWxzXG4gICAgICAgIC5lbnRyaWVzKClcbiAgICAgICAgLm1hcCgoW25hbWUsIGlkZW50aWZpZXJdKSA9PlxuICAgICAgICAgIHQub2JqZWN0UHJvcGVydHkodC5pZGVudGlmaWVyKG5hbWUpLCB0LmlkZW50aWZpZXIoaWRlbnRpZmllciksIGZhbHNlLCB0cnVlKVxuICAgICAgICApXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gdXBkYXRlU2NvcGUoYmFiZWw6IHR5cGVvZiBCYWJlbCwgdGFyZ2V0OiBOb2RlUGF0aDx0LkNhbGxFeHByZXNzaW9uPiwgbG9jYWxzOiBTY29wZUxvY2Fscykge1xuICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuICBsZXQgc2Vjb25kQXJnID0gdGFyZ2V0LmdldCgnYXJndW1lbnRzLjEnKSBhcyBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+IHwgdW5kZWZpbmVkO1xuICBpZiAoc2Vjb25kQXJnKSB7XG4gICAgbGV0IHNjb3BlID0gc2Vjb25kQXJnLmdldCgncHJvcGVydGllcycpLmZpbmQoKHApID0+IHtcbiAgICAgIGxldCBrZXkgPSBwLmdldCgna2V5JykgYXMgTm9kZVBhdGg8dC5Ob2RlPjtcbiAgICAgIHJldHVybiBrZXkuaXNJZGVudGlmaWVyKCkgJiYga2V5Lm5vZGUubmFtZSA9PT0gJ3Njb3BlJztcbiAgICB9KTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIHNjb3BlLnNldCgndmFsdWUnLCBidWlsZFNjb3BlKGJhYmVsLCBsb2NhbHMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vjb25kQXJnLnB1c2hDb250YWluZXIoXG4gICAgICAgICdwcm9wZXJ0aWVzJyxcbiAgICAgICAgdC5vYmplY3RQcm9wZXJ0eSh0LmlkZW50aWZpZXIoJ3Njb3BlJyksIGJ1aWxkU2NvcGUoYmFiZWwsIGxvY2FscykpXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQucHVzaENvbnRhaW5lcihcbiAgICAgICdhcmd1bWVudHMnLFxuICAgICAgdC5vYmplY3RFeHByZXNzaW9uKFt0Lm9iamVjdFByb3BlcnR5KHQuaWRlbnRpZmllcignc2NvcGUnKSwgYnVpbGRTY29wZShiYWJlbCwgbG9jYWxzKSldKVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZhbEFuZFNjb3BlKHRhcmdldDogTm9kZVBhdGg8dC5DYWxsRXhwcmVzc2lvbj4pIHtcbiAgbGV0IHNlY29uZEFyZyA9IHRhcmdldC5nZXQoJ2FyZ3VtZW50cy4xJykgYXMgTm9kZVBhdGg8dC5PYmplY3RFeHByZXNzaW9uPiB8IHVuZGVmaW5lZDtcbiAgaWYgKHNlY29uZEFyZykge1xuICAgIGxldCBldmFsUHJvcCA9IHNlY29uZEFyZy5nZXQoJ3Byb3BlcnRpZXMnKS5maW5kKChwKSA9PiB7XG4gICAgICBsZXQga2V5ID0gcC5nZXQoJ2tleScpIGFzIE5vZGVQYXRoPHQuTm9kZT47XG4gICAgICByZXR1cm4ga2V5LmlzSWRlbnRpZmllcigpICYmIGtleS5ub2RlLm5hbWUgPT09ICdldmFsJztcbiAgICB9KTtcbiAgICBpZiAoZXZhbFByb3ApIHtcbiAgICAgIGV2YWxQcm9wLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGxldCBjb21wb25lbnRQcm9wID0gc2Vjb25kQXJnLmdldCgncHJvcGVydGllcycpLmZpbmQoKHApID0+IHtcbiAgICAgIGxldCBrZXkgPSBwLmdldCgna2V5JykgYXMgTm9kZVBhdGg8dC5Ob2RlPjtcbiAgICAgIHJldHVybiBrZXkuaXNJZGVudGlmaWVyKCkgJiYga2V5Lm5vZGUubmFtZSA9PT0gJ2NvbXBvbmVudCc7XG4gICAgfSk7XG4gICAgaWYgKGNvbXBvbmVudFByb3ApIHtcbiAgICAgIGNvbXBvbmVudFByb3AucmVtb3ZlKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIEdpdmVuIGEgY2FsbCB0byB0ZW1wbGF0ZSgpLCBjb252ZXJ0IGl0cyBcInN0cmljdFwiIGFyZ3VtZW50IGludG9cbi8vIHByZWNvbXBpbGVUZW1wbGF0ZSdzIFwic3RyaWN0TW9kZVwiIGFyZ3VtZW50LiBUaGV5IGRpZmZlciBpbiBuYW1lIGFuZCBkZWZhdWx0XG4vLyB2YWx1ZS5cbmZ1bmN0aW9uIGNvbnZlcnRTdHJpY3RNb2RlKGJhYmVsOiB0eXBlb2YgQmFiZWwsIHRhcmdldDogTm9kZVBhdGg8dC5DYWxsRXhwcmVzc2lvbj4pIHtcbiAgbGV0IHQgPSBiYWJlbC50eXBlcztcbiAgbGV0IHNlY29uZEFyZyA9IHRhcmdldC5nZXQoJ2FyZ3VtZW50cy4xJykgYXMgTm9kZVBhdGg8dC5PYmplY3RFeHByZXNzaW9uPiB8IHVuZGVmaW5lZDtcbiAgaWYgKHNlY29uZEFyZykge1xuICAgIGxldCBzdHJpY3QgPSBzZWNvbmRBcmcuZ2V0KCdwcm9wZXJ0aWVzJykuZmluZCgocCkgPT4ge1xuICAgICAgbGV0IGtleSA9IHAuZ2V0KCdrZXknKSBhcyBOb2RlUGF0aDx0Lk5vZGU+O1xuICAgICAgcmV0dXJuIGtleS5pc0lkZW50aWZpZXIoKSAmJiBrZXkubm9kZS5uYW1lID09PSAnc3RyaWN0JztcbiAgICB9KSBhcyBOb2RlUGF0aDx0Lk9iamVjdFByb3BlcnR5PjtcbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICBzdHJpY3Quc2V0KCdrZXknLCB0LmlkZW50aWZpZXIoJ3N0cmljdE1vZGUnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlY29uZEFyZy5wdXNoQ29udGFpbmVyKFxuICAgICAgICAncHJvcGVydGllcycsXG4gICAgICAgIHQub2JqZWN0UHJvcGVydHkodC5pZGVudGlmaWVyKCdzdHJpY3RNb2RlJyksIHQuYm9vbGVhbkxpdGVyYWwodHJ1ZSkpXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQucHVzaENvbnRhaW5lcihcbiAgICAgICdhcmd1bWVudHMnLFxuICAgICAgdC5vYmplY3RFeHByZXNzaW9uKFt0Lm9iamVjdFByb3BlcnR5KHQuaWRlbnRpZmllcignc3RyaWN0TW9kZScpLCB0LmJvb2xlYW5MaXRlcmFsKHRydWUpKV0pXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVBydW5lSW1wb3J0KFxuICB1dGlsOiBJbXBvcnRVdGlsLFxuICBpZGVudGlmaWVyOiBOb2RlUGF0aDx0LkV4cHJlc3Npb24gfCB0LlY4SW50cmluc2ljSWRlbnRpZmllcj5cbikge1xuICBpZiAoIWlkZW50aWZpZXIuaXNJZGVudGlmaWVyKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGJpbmRpbmcgPSBpZGVudGlmaWVyLnNjb3BlLmdldEJpbmRpbmcoaWRlbnRpZmllci5ub2RlLm5hbWUpO1xuICAvLyB0aGlzIGNoZWNrcyBpZiB0aGUgaWRlbnRpZmllciAodGhhdCB3ZSdyZSBhYm91dCB0byByZW1vdmUpIGlzIHVzZWQgaW5cbiAgLy8gZXhhY3RseSBvbmUgcGxhY2UuXG4gIGlmIChcbiAgICBiaW5kaW5nPy5yZWZlcmVuY2VQYXRocy5yZWR1Y2UoKGNvdW50LCBwYXRoKSA9PiAocGF0aC5yZW1vdmVkID8gY291bnQgOiBjb3VudCArIDEpLCAwKSA9PT0gMVxuICApIHtcbiAgICBsZXQgc3BlY2lmaWVyID0gYmluZGluZy5wYXRoO1xuICAgIGlmIChzcGVjaWZpZXIuaXNJbXBvcnRTcGVjaWZpZXIoKSkge1xuICAgICAgbGV0IGRlY2xhcmF0aW9uID0gc3BlY2lmaWVyLnBhcmVudFBhdGggYXMgTm9kZVBhdGg8dC5JbXBvcnREZWNsYXJhdGlvbj47XG4gICAgICB1dGlsLnJlbW92ZUltcG9ydChkZWNsYXJhdGlvbi5ub2RlLnNvdXJjZS52YWx1ZSwgbmFtZShzcGVjaWZpZXIubm9kZS5pbXBvcnRlZCkpO1xuICAgIH1cbiAgfVxuICBpZGVudGlmaWVyLnJlbW92ZWQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBwcmVjb21waWxlVGVtcGxhdGUodXRpbDogSW1wb3J0VXRpbCwgdGFyZ2V0OiBOb2RlUGF0aDx0Lk5vZGU+KSB7XG4gIHJldHVybiB1dGlsLmltcG9ydCh0YXJnZXQsICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nLCAncHJlY29tcGlsZVRlbXBsYXRlJyk7XG59XG5cbmZ1bmN0aW9uIG5hbWUobm9kZTogdC5TdHJpbmdMaXRlcmFsIHwgdC5JZGVudGlmaWVyKSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdTdHJpbmdMaXRlcmFsJykge1xuICAgIHJldHVybiBub2RlLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2RlLm5hbWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFrZVBsdWdpbjxPcHRpb25zPigob3B0aW9ucykgPT4gb3B0aW9ucyk7XG4iXX0=