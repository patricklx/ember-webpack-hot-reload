import type { Package } from '@embroider/shared-internals';
import { RewrittenPackageCache } from '@embroider/shared-internals';
import type UserOptions from './options';
export interface Options {
    renamePackages: {
        [fromName: string]: string;
    };
    renameModules: {
        [fromName: string]: string;
    };
    activeAddons: {
        [packageName: string]: string;
    };
    resolvableExtensions: string[];
    appRoot: string;
    engines: EngineConfig[];
    modulePrefix: string;
    podModulePrefix?: string;
    amdCompatibility: Required<UserOptions['amdCompatibility']>;
}
interface EngineConfig {
    packageName: string;
    activeAddons: {
        name: string;
        root: string;
    }[];
    fastbootFiles: {
        [appName: string]: {
            localFilename: string;
            shadowedFilename: string | undefined;
        };
    };
    root: string;
}
export interface ModuleRequest {
    readonly specifier: string;
    readonly fromFile: string;
    readonly isVirtual: boolean;
    readonly meta: Record<string, unknown> | undefined;
    alias(newSpecifier: string): this;
    rehome(newFromFile: string): this;
    virtualize(virtualFilename: string): this;
    withMeta(meta: Record<string, any> | undefined): this;
}
export type Resolution<T = unknown, E = unknown> = {
    type: 'found';
    result: T;
} | {
    type: 'not_found';
    err: E;
};
export type ResolverFunction<R extends ModuleRequest = ModuleRequest, Res extends Resolution = Resolution> = (request: R) => Promise<Res>;
export type SyncResolverFunction<R extends ModuleRequest = ModuleRequest, Res extends Resolution = Resolution> = (request: R) => Res;
export declare class Resolver {
    readonly options: Options;
    constructor(options: Options);
    beforeResolve<R extends ModuleRequest>(request: R): R;
    resolve<Req extends ModuleRequest, Res extends Resolution>(request: Req, defaultResolve: ResolverFunction<Req, Res>): Promise<Res>;
    resolveSync<Req extends ModuleRequest, Res extends Resolution>(request: Req, defaultResolve: SyncResolverFunction<Req, Res>): Res;
    private internalResolve;
    nodeResolve(specifier: string, fromFile: string): {
        type: 'virtual';
        filename: string;
        content: string;
    } | {
        type: 'real';
        filename: string;
    } | {
        type: 'not_found';
        err: Error;
    };
    get packageCache(): RewrittenPackageCache;
    private logicalPackage;
    private generateFastbootSwitch;
    private handleFastbootSwitch;
    private handleImplicitModules;
    private handleGlobalsCompat;
    private resolveHelper;
    private resolveComponent;
    private resolveHelperOrComponent;
    private resolveModifier;
    private componentTemplateCandidates;
    private componentJSCandidates;
    private podPrefix;
    private parseGlobalPath;
    private engineConfig;
    private get mergeMap();
    owningEngine(pkg: Package): EngineConfig;
    private handleRewrittenPackages;
    private handleRenaming;
    private resolveWithinPackage;
    private preHandleExternal;
    private external;
    fallbackResolve<R extends ModuleRequest>(request: R): R;
    private getEntryFromMergeMap;
    private withResolvableExtensions;
    private searchAppTree;
    private reverseSearchAppTree;
    reverseComponentLookup(filename: string): string | undefined;
    private tryReverseComponent;
}
export {};
