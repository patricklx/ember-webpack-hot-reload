"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeImplicitModules = exports.decodeFastbootSwitch = exports.fastbootSwitch = exports.virtualPairComponent = exports.virtualExternalCJSModule = exports.virtualExternalESModule = exports.virtualContent = void 0;
const path_1 = require("path");
const _1 = require(".");
const js_handlebars_1 = require("./js-handlebars");
const externalESPrefix = '/@embroider/ext-es/';
const externalCJSPrefix = '/@embroider/ext-cjs/';
// Given a filename that was passed to your ModuleRequest's `virtualize()`,
// this produces the corresponding contents. It's a static, stateless function
// because we recognize that that process that did resolution might not be the
// same one that loads the content.
function virtualContent(filename, resolver) {
    let cjsExtern = decodeVirtualExternalCJSModule(filename);
    if (cjsExtern) {
        return renderCJSExternalShim(cjsExtern);
    }
    let extern = decodeVirtualExternalESModule(filename);
    if (extern) {
        return renderESExternalShim(extern);
    }
    let match = decodeVirtualPairComponent(filename);
    if (match) {
        return pairedComponentShim(match);
    }
    let fb = decodeFastbootSwitch(filename);
    if (fb) {
        return fastbootSwitchTemplate(fb);
    }
    let im = decodeImplicitModules(filename);
    if (im) {
        return renderImplicitModules(im, resolver);
    }
    throw new Error(`not an @embroider/core virtual file: ${filename}`);
}
exports.virtualContent = virtualContent;
const externalESShim = (0, js_handlebars_1.compile)(`
{{#if (eq moduleName "require")}}
const m = window.requirejs;
export default m;
const has = m.has;
export { has }
{{else}}
const m = window.require("{{{js-string-escape moduleName}}}");
{{#if default}}
export default m.default;
{{/if}}
{{#if names}}
const { {{#each names as |name|}}{{name}}, {{/each}} } = m;
export { {{#each names as |name|}}{{name}}, {{/each}} }
{{/if}}
{{/if}}
`);
function renderESExternalShim({ moduleName, exports }) {
    return externalESShim({
        moduleName,
        default: exports.includes('default'),
        names: exports.filter(n => n !== 'default'),
    });
}
const pairedComponentShim = (0, js_handlebars_1.compile)(`
import { setComponentTemplate } from "@ember/component";
import template from "{{{js-string-escape relativeHBSModule}}}";
{{#if relativeJSModule}}
import component from "{{{js-string-escape relativeJSModule}}}";
export default setComponentTemplate(template, component);
{{else}}
import templateOnlyComponent from "@ember/component/template-only";
export default setComponentTemplate(template, templateOnlyComponent(undefined, "{{{js-string-escape debugName}}}"));
{{/if}}
`);
function virtualExternalESModule(specifier, exports) {
    if (exports) {
        return externalESPrefix + specifier + `?exports=${exports.join(',')}`;
    }
    else {
        return externalESPrefix + specifier;
    }
}
exports.virtualExternalESModule = virtualExternalESModule;
function virtualExternalCJSModule(specifier) {
    return externalCJSPrefix + specifier;
}
exports.virtualExternalCJSModule = virtualExternalCJSModule;
function decodeVirtualExternalESModule(filename) {
    if (filename.startsWith(externalESPrefix)) {
        let exports = [];
        let url = new URL(filename.slice(externalESPrefix.length), 'http://example.com');
        let nameString = url.searchParams.get('exports');
        if (nameString) {
            exports = nameString.split(',');
        }
        let moduleName = url.pathname.slice(1);
        return { moduleName, exports };
    }
}
function decodeVirtualExternalCJSModule(filename) {
    if (filename.startsWith(externalCJSPrefix)) {
        return { moduleName: filename.slice(externalCJSPrefix.length) };
    }
}
const pairComponentMarker = '/embroider-pair-component';
const pairComponentPattern = /^(?<hbsModule>.*)\/(?<jsModule>[^\/]*)\/embroider-pair-component$/;
function virtualPairComponent(hbsModule, jsModule) {
    let relativeJSModule = '';
    if (jsModule) {
        // The '/j/' here represents the relativeJSModule itself that we're about to
        // use to create the complete filename. It's there to get the right number
        // of `..` in our relative path.
        relativeJSModule = (0, _1.explicitRelative)(hbsModule + '/j/', jsModule);
    }
    return `${hbsModule}/${encodeURIComponent(relativeJSModule)}${pairComponentMarker}`;
}
exports.virtualPairComponent = virtualPairComponent;
function decodeVirtualPairComponent(filename) {
    // Performance: avoid paying regex exec cost unless needed
    if (!filename.includes(pairComponentMarker)) {
        return null;
    }
    let match = pairComponentPattern.exec(filename);
    if (!match) {
        return null;
    }
    let { hbsModule, jsModule } = match.groups;
    // target our real hbs module from our virtual module
    let relativeHBSModule = (0, _1.explicitRelative)((0, path_1.dirname)(filename), hbsModule);
    return {
        relativeHBSModule,
        relativeJSModule: decodeURIComponent(jsModule) || null,
        debugName: (0, path_1.basename)(relativeHBSModule).replace(/\.(js|hbs)$/, ''),
    };
}
const fastbootSwitchSuffix = '/embroider_fastboot_switch';
const fastbootSwitchPattern = /(?<original>.+)\/embroider_fastboot_switch(?:\?names=(?<names>.+))?$/;
function fastbootSwitch(specifier, fromFile, names) {
    let filename = `${(0, path_1.resolve)((0, path_1.dirname)(fromFile), specifier)}${fastbootSwitchSuffix}`;
    if (names.size > 0) {
        return `${filename}?names=${[...names].join(',')}`;
    }
    else {
        return filename;
    }
}
exports.fastbootSwitch = fastbootSwitch;
function decodeFastbootSwitch(filename) {
    var _a, _b, _c;
    // Performance: avoid paying regex exec cost unless needed
    if (!filename.includes(fastbootSwitchSuffix)) {
        return;
    }
    let match = fastbootSwitchPattern.exec(filename);
    if (match) {
        let names = (_c = (_b = (_a = match.groups) === null || _a === void 0 ? void 0 : _a.names) === null || _b === void 0 ? void 0 : _b.split(',')) !== null && _c !== void 0 ? _c : [];
        return {
            names: names.filter(name => name !== 'default'),
            hasDefaultExport: names.includes('default'),
            filename: match.groups.original,
        };
    }
}
exports.decodeFastbootSwitch = decodeFastbootSwitch;
const fastbootSwitchTemplate = (0, js_handlebars_1.compile)(`
import { macroCondition, getGlobalConfig, importSync } from '@embroider/macros';
let mod;
if (macroCondition(getGlobalConfig().fastboot?.isRunning)){
  mod = importSync('./fastboot');
} else {
  mod = importSync('./browser');
}
{{#if hasDefaultExport}}
export default mod.default;
{{/if}}
{{#each names as |name|}}
export const {{name}} = mod.{{name}};
{{/each}}
`);
const implicitModulesPattern = /(?<filename>.*)[\\/]-embroider-implicit-(?<test>test-)?modules\.js$/;
function decodeImplicitModules(filename) {
    // Performance: avoid paying regex exec cost unless needed
    if (!filename.includes('-embroider-implicit-')) {
        return;
    }
    let m = implicitModulesPattern.exec(filename);
    if (m) {
        return {
            type: m.groups.test ? 'implicit-test-modules' : 'implicit-modules',
            fromFile: m.groups.filename,
        };
    }
}
exports.decodeImplicitModules = decodeImplicitModules;
function renderImplicitModules({ type, fromFile, }, resolver) {
    let resolvableExtensionsPattern = (0, _1.extensionsPattern)(resolver.options.resolvableExtensions);
    const pkg = resolver.packageCache.ownerOfFile(fromFile);
    if (!(pkg === null || pkg === void 0 ? void 0 : pkg.isV2Ember())) {
        throw new Error(`bug: saw special implicit modules import in non-ember package at ${fromFile}`);
    }
    let lazyModules = [];
    let eagerModules = [];
    let deps = pkg.dependencies.sort(orderAddons);
    for (let dep of deps) {
        // anything that isn't a v2 ember package by this point is not an active
        // addon.
        if (!dep.isV2Addon()) {
            continue;
        }
        // we ignore peerDependencies here because classic ember-cli ignores
        // peerDependencies here, and we're implementing the implicit-modules
        // backward-comptibility feature.
        if (pkg.categorizeDependency(dep.name) === 'peerDependencies') {
            continue;
        }
        let implicitModules = dep.meta[type];
        if (implicitModules) {
            let renamedModules = inverseRenamedModules(dep.meta, resolvableExtensionsPattern);
            for (let name of implicitModules) {
                let packageName = dep.name;
                let renamedMeta = dep.meta['renamed-packages'];
                if (renamedMeta) {
                    Object.entries(renamedMeta).forEach(([key, value]) => {
                        if (value === dep.name) {
                            packageName = key;
                        }
                    });
                }
                let runtime = (0, path_1.join)(packageName, name).replace(resolvableExtensionsPattern, '');
                let runtimeRenameLookup = runtime.split('\\').join('/');
                if (renamedModules && renamedModules[runtimeRenameLookup]) {
                    runtime = renamedModules[runtimeRenameLookup];
                }
                runtime = runtime.split(path_1.sep).join('/');
                lazyModules.push({
                    runtime,
                    buildtime: path_1.posix.join(packageName, name),
                });
            }
        }
        // we don't recurse across an engine boundary. Engines import their own
        // implicit-modules.
        if (!dep.isEngine()) {
            eagerModules.push(path_1.posix.join(dep.name, `-embroider-${type}.js`));
        }
    }
    return implicitModulesTemplate({ lazyModules, eagerModules });
}
const implicitModulesTemplate = (0, js_handlebars_1.compile)(`
import { importSync as i } from '@embroider/macros';
let d = window.define;
{{#each lazyModules as |module|}}
d("{{js-string-escape module.runtime}}", function(){ return i("{{js-string-escape module.buildtime}}");});
{{/each}}
{{#each eagerModules as |module|}}
import "{{js-string-escape module}}";
{{/each}}
`);
// meta['renamed-modules'] has mapping from classic filename to real filename.
// This takes that and converts it to the inverst mapping from real import path
// to classic import path.
function inverseRenamedModules(meta, extensions) {
    let renamed = meta['renamed-modules'];
    if (renamed) {
        let inverted = {};
        for (let [classic, real] of Object.entries(renamed)) {
            inverted[real.replace(extensions, '')] = classic.replace(extensions, '');
        }
        return inverted;
    }
}
function orderAddons(depA, depB) {
    let depAIdx = 0;
    let depBIdx = 0;
    if (depA && depA.meta && depA.isV2Addon()) {
        depAIdx = depA.meta['order-index'] || 0;
    }
    if (depB && depB.meta && depB.isV2Addon()) {
        depBIdx = depB.meta['order-index'] || 0;
    }
    return depAIdx - depBIdx;
}
const renderCJSExternalShim = (0, js_handlebars_1.compile)(`
{{#if (eq moduleName "require")}}
const m = window.requirejs;
{{else}}
const m = window.require("{{{js-string-escape moduleName}}}");
{{/if}}
{{!-
  There are plenty of hand-written AMD defines floating around
  that lack this, and they will break when other build systems
  encounter them.

  As far as I can tell, Ember's loader was already treating this
  case as a module, so in theory we aren't breaking anything by
  marking it as such when other packagers come looking.

  todo: get review on this part.
-}}
if (m.default && !m.__esModule) {
  m.__esModule = true;
}
module.exports = m;
`);
//# sourceMappingURL=virtual-content.js.map