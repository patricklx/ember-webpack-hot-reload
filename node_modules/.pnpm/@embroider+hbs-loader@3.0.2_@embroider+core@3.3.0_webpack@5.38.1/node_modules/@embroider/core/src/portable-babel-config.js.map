{"version":3,"file":"portable-babel-config.js","sourceRoot":"","sources":["portable-babel-config.ts"],"names":[],"mappings":"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","sourcesContent":["import type { TransformOptions } from '@babel/core';\nimport { join } from 'path';\nimport resolve from 'resolve';\nimport type { PortableHint } from './portable';\nimport { Portable } from './portable';\n\nexport type ResolveOptions = { basedir: string } | { resolve: (name: string) => any };\n\nexport function makePortable(\n  config: TransformOptions,\n  resolveOptions: ResolveOptions,\n  hints: PortableHint[]\n): { config: TransformOptions; isParallelSafe: boolean } {\n  return new PortableBabelConfig(resolveOptions, hints).convert(config);\n}\n\nclass PortableBabelConfig {\n  private resolve: (name: string) => any;\n  private basedir: string | undefined;\n\n  constructor(resolveOptions: ResolveOptions, private hints: PortableHint[]) {\n    if ('resolve' in resolveOptions) {\n      this.resolve = resolveOptions.resolve;\n    } else {\n      this.basedir = resolveOptions.basedir;\n      this.resolve = (name: string) => resolve.sync(name, { basedir: resolveOptions.basedir });\n    }\n  }\n\n  convert(config: TransformOptions): { config: TransformOptions; isParallelSafe: boolean } {\n    let portable: Portable = new Portable({\n      hints: this.hints,\n      dehydrate: (value: any, accessPath: string[]) => {\n        // this custom dehydrate hook handles babel plugins & presets. If we're\n        // not looking at plugins or presets, continue with stock Portable\n        // behavior\n        if (accessPath.length !== 2 || (accessPath[0] !== 'plugins' && accessPath[0] !== 'presets')) {\n          return undefined;\n        }\n\n        // standardize to always handle an array\n        if (!Array.isArray(value)) {\n          value = [value];\n        }\n\n        let [plugin, argument, asName] = value;\n\n        // string plugins need to get resolved correctly into absolute paths,\n        // so they will really be portable\n        if (typeof plugin === 'string') {\n          plugin = this.resolveBabelPlugin(plugin);\n        }\n\n        // next we deal with serializability. Our Portable system already\n        // understands the protocol used by ember-cli-babel to identify plugin\n        // classes and get back to their serializable forms, so this will\n        // handle that case.\n        let dehydrated = portable.dehydrate([plugin, argument, asName], accessPath.concat('_internal'));\n\n        if (dehydrated.needsHydrate) {\n          // we can eliminate the need for rehydration by going through our own\n          // portable babel launcher\n          return {\n            value: [\n              join(__dirname, 'portable-babel-launcher.js'),\n              { module: dehydrated.value[0], arg: dehydrated.value[1], hints: this.hints },\n              dehydrated.value[2] || `portable-babel-launcher-${accessPath[1]}`,\n            ],\n            needsHydrate: false,\n            isParallelSafe: dehydrated.isParallelSafe,\n          };\n        } else {\n          // trim back down our array, because trailing undefined will get\n          // converted into null via json.stringify, and babel will complain\n          // about that.\n          while (dehydrated.value.length > 0 && dehydrated.value[dehydrated.value.length - 1] == null) {\n            dehydrated.value.pop();\n          }\n          if (dehydrated.value.length === 1) {\n            dehydrated.value = dehydrated.value[0];\n          }\n          return {\n            value: dehydrated.value,\n            needsHydrate: dehydrated.needsHydrate,\n            isParallelSafe: dehydrated.isParallelSafe,\n          };\n        }\n      },\n    });\n    let result = portable.dehydrate(config);\n    if (result.needsHydrate) {\n      throw new Error(`bug: portable babel configs aren't supposed to need hydration`);\n    }\n    return { config: result.value, isParallelSafe: result.isParallelSafe };\n  }\n\n  // babel lets you use relative paths, absolute paths, package names, and\n  // package name shorthands.\n  //\n  // my-plugin  -> my-plugin\n  // my-plugin  -> babel-plugin-my-plugin\n  // @me/thing  -> @me/thing\n  // @me/thing  -> @me/babel-plugin-thing\n  // ./here     -> /your/app/here\n  // /tmp/there -> /tmp/there\n  //\n  private resolveBabelPlugin(name: string) {\n    try {\n      return this.resolve(name);\n    } catch (err) {\n      if (err.code !== 'MODULE_NOT_FOUND') {\n        throw err;\n      }\n      if (name.startsWith('.') || name.startsWith('/')) {\n        throw err;\n      }\n      try {\n        let expanded;\n        if (name.startsWith('@')) {\n          let [space, pkg, ...rest] = name.split('/');\n          expanded = [space, `babel-plugin-${pkg}`, ...rest].join('/');\n        } else {\n          expanded = `babel-plugin-${name}`;\n        }\n        return this.resolve(expanded);\n      } catch (err2) {\n        if (err2.code !== 'MODULE_NOT_FOUND') {\n          throw err2;\n        }\n        if (this.basedir) {\n          throw new Error(`unable to resolve babel plugin ${name} from ${this.basedir}`);\n        } else {\n          throw new Error(`unable to resolve babel plugin ${name}`);\n        }\n      }\n    }\n  }\n}\n"]}