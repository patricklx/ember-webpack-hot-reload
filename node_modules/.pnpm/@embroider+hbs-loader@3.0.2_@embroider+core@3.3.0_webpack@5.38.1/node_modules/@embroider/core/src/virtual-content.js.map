{"version":3,"file":"virtual-content.js","sourceRoot":"","sources":["virtual-content.ts"],"names":[],"mappings":"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","sourcesContent":["import { dirname, basename, resolve, posix, sep, join } from 'path';\nimport type { Resolver, AddonPackage, Package } from '.';\nimport { explicitRelative, extensionsPattern } from '.';\nimport { compile } from './js-handlebars';\n\nconst externalESPrefix = '/@embroider/ext-es/';\nconst externalCJSPrefix = '/@embroider/ext-cjs/';\n\n// Given a filename that was passed to your ModuleRequest's `virtualize()`,\n// this produces the corresponding contents. It's a static, stateless function\n// because we recognize that that process that did resolution might not be the\n// same one that loads the content.\nexport function virtualContent(filename: string, resolver: Resolver): string {\n  let cjsExtern = decodeVirtualExternalCJSModule(filename);\n  if (cjsExtern) {\n    return renderCJSExternalShim(cjsExtern);\n  }\n\n  let extern = decodeVirtualExternalESModule(filename);\n  if (extern) {\n    return renderESExternalShim(extern);\n  }\n  let match = decodeVirtualPairComponent(filename);\n  if (match) {\n    return pairedComponentShim(match);\n  }\n\n  let fb = decodeFastbootSwitch(filename);\n  if (fb) {\n    return fastbootSwitchTemplate(fb);\n  }\n\n  let im = decodeImplicitModules(filename);\n  if (im) {\n    return renderImplicitModules(im, resolver);\n  }\n\n  throw new Error(`not an @embroider/core virtual file: ${filename}`);\n}\n\nconst externalESShim = compile(`\n{{#if (eq moduleName \"require\")}}\nconst m = window.requirejs;\nexport default m;\nconst has = m.has;\nexport { has }\n{{else}}\nconst m = window.require(\"{{{js-string-escape moduleName}}}\");\n{{#if default}}\nexport default m.default;\n{{/if}}\n{{#if names}}\nconst { {{#each names as |name|}}{{name}}, {{/each}} } = m;\nexport { {{#each names as |name|}}{{name}}, {{/each}} }\n{{/if}}\n{{/if}}\n`) as (params: { moduleName: string; default: boolean; names: string[] }) => string;\n\nfunction renderESExternalShim({ moduleName, exports }: { moduleName: string; exports: string[] }): string {\n  return externalESShim({\n    moduleName,\n    default: exports.includes('default'),\n    names: exports.filter(n => n !== 'default'),\n  });\n}\n\nconst pairedComponentShim = compile(`\nimport { setComponentTemplate } from \"@ember/component\";\nimport template from \"{{{js-string-escape relativeHBSModule}}}\";\n{{#if relativeJSModule}}\nimport component from \"{{{js-string-escape relativeJSModule}}}\";\nexport default setComponentTemplate(template, component);\n{{else}}\nimport templateOnlyComponent from \"@ember/component/template-only\";\nexport default setComponentTemplate(template, templateOnlyComponent(undefined, \"{{{js-string-escape debugName}}}\"));\n{{/if}}\n`) as (params: { relativeHBSModule: string; relativeJSModule: string | null; debugName: string }) => string;\n\nexport function virtualExternalESModule(specifier: string, exports: string[] | undefined): string {\n  if (exports) {\n    return externalESPrefix + specifier + `?exports=${exports.join(',')}`;\n  } else {\n    return externalESPrefix + specifier;\n  }\n}\n\nexport function virtualExternalCJSModule(specifier: string): string {\n  return externalCJSPrefix + specifier;\n}\n\nfunction decodeVirtualExternalESModule(filename: string): { moduleName: string; exports: string[] } | undefined {\n  if (filename.startsWith(externalESPrefix)) {\n    let exports: string[] = [];\n    let url = new URL(filename.slice(externalESPrefix.length), 'http://example.com');\n    let nameString = url.searchParams.get('exports');\n    if (nameString) {\n      exports = nameString.split(',');\n    }\n    let moduleName = url.pathname.slice(1);\n    return { moduleName, exports };\n  }\n}\n\nfunction decodeVirtualExternalCJSModule(filename: string) {\n  if (filename.startsWith(externalCJSPrefix)) {\n    return { moduleName: filename.slice(externalCJSPrefix.length) };\n  }\n}\n\nconst pairComponentMarker = '/embroider-pair-component';\nconst pairComponentPattern = /^(?<hbsModule>.*)\\/(?<jsModule>[^\\/]*)\\/embroider-pair-component$/;\n\nexport function virtualPairComponent(hbsModule: string, jsModule: string | null): string {\n  let relativeJSModule = '';\n  if (jsModule) {\n    // The '/j/' here represents the relativeJSModule itself that we're about to\n    // use to create the complete filename. It's there to get the right number\n    // of `..` in our relative path.\n    relativeJSModule = explicitRelative(hbsModule + '/j/', jsModule);\n  }\n  return `${hbsModule}/${encodeURIComponent(relativeJSModule)}${pairComponentMarker}`;\n}\n\nfunction decodeVirtualPairComponent(\n  filename: string\n): { relativeHBSModule: string; relativeJSModule: string | null; debugName: string } | null {\n  // Performance: avoid paying regex exec cost unless needed\n  if (!filename.includes(pairComponentMarker)) {\n    return null;\n  }\n  let match = pairComponentPattern.exec(filename);\n  if (!match) {\n    return null;\n  }\n  let { hbsModule, jsModule } = match.groups! as { hbsModule: string; jsModule: string };\n  // target our real hbs module from our virtual module\n  let relativeHBSModule = explicitRelative(dirname(filename), hbsModule);\n  return {\n    relativeHBSModule,\n    relativeJSModule: decodeURIComponent(jsModule) || null,\n    debugName: basename(relativeHBSModule).replace(/\\.(js|hbs)$/, ''),\n  };\n}\n\nconst fastbootSwitchSuffix = '/embroider_fastboot_switch';\nconst fastbootSwitchPattern = /(?<original>.+)\\/embroider_fastboot_switch(?:\\?names=(?<names>.+))?$/;\nexport function fastbootSwitch(specifier: string, fromFile: string, names: Set<string>): string {\n  let filename = `${resolve(dirname(fromFile), specifier)}${fastbootSwitchSuffix}`;\n  if (names.size > 0) {\n    return `${filename}?names=${[...names].join(',')}`;\n  } else {\n    return filename;\n  }\n}\n\nexport function decodeFastbootSwitch(filename: string) {\n  // Performance: avoid paying regex exec cost unless needed\n  if (!filename.includes(fastbootSwitchSuffix)) {\n    return;\n  }\n  let match = fastbootSwitchPattern.exec(filename);\n  if (match) {\n    let names = match.groups?.names?.split(',') ?? [];\n    return {\n      names: names.filter(name => name !== 'default'),\n      hasDefaultExport: names.includes('default'),\n      filename: match.groups!.original,\n    };\n  }\n}\n\nconst fastbootSwitchTemplate = compile(`\nimport { macroCondition, getGlobalConfig, importSync } from '@embroider/macros';\nlet mod;\nif (macroCondition(getGlobalConfig().fastboot?.isRunning)){\n  mod = importSync('./fastboot');\n} else {\n  mod = importSync('./browser');\n}\n{{#if hasDefaultExport}}\nexport default mod.default;\n{{/if}}\n{{#each names as |name|}}\nexport const {{name}} = mod.{{name}};\n{{/each}}\n`) as (params: { names: string[]; hasDefaultExport: boolean }) => string;\n\nconst implicitModulesPattern = /(?<filename>.*)[\\\\/]-embroider-implicit-(?<test>test-)?modules\\.js$/;\n\nexport function decodeImplicitModules(\n  filename: string\n): { type: 'implicit-modules' | 'implicit-test-modules'; fromFile: string } | undefined {\n  // Performance: avoid paying regex exec cost unless needed\n  if (!filename.includes('-embroider-implicit-')) {\n    return;\n  }\n  let m = implicitModulesPattern.exec(filename);\n  if (m) {\n    return {\n      type: m.groups!.test ? 'implicit-test-modules' : 'implicit-modules',\n      fromFile: m.groups!.filename,\n    };\n  }\n}\n\nfunction renderImplicitModules(\n  {\n    type,\n    fromFile,\n  }: {\n    type: 'implicit-modules' | 'implicit-test-modules';\n    fromFile: string;\n  },\n  resolver: Resolver\n): string {\n  let resolvableExtensionsPattern = extensionsPattern(resolver.options.resolvableExtensions);\n\n  const pkg = resolver.packageCache.ownerOfFile(fromFile);\n  if (!pkg?.isV2Ember()) {\n    throw new Error(`bug: saw special implicit modules import in non-ember package at ${fromFile}`);\n  }\n\n  let lazyModules: { runtime: string; buildtime: string }[] = [];\n  let eagerModules: string[] = [];\n\n  let deps = pkg.dependencies.sort(orderAddons);\n\n  for (let dep of deps) {\n    // anything that isn't a v2 ember package by this point is not an active\n    // addon.\n    if (!dep.isV2Addon()) {\n      continue;\n    }\n\n    // we ignore peerDependencies here because classic ember-cli ignores\n    // peerDependencies here, and we're implementing the implicit-modules\n    // backward-comptibility feature.\n    if (pkg.categorizeDependency(dep.name) === 'peerDependencies') {\n      continue;\n    }\n\n    let implicitModules = dep.meta[type];\n    if (implicitModules) {\n      let renamedModules = inverseRenamedModules(dep.meta, resolvableExtensionsPattern);\n      for (let name of implicitModules) {\n        let packageName = dep.name;\n\n        let renamedMeta = dep.meta['renamed-packages'];\n        if (renamedMeta) {\n          Object.entries(renamedMeta).forEach(([key, value]) => {\n            if (value === dep.name) {\n              packageName = key;\n            }\n          });\n        }\n\n        let runtime = join(packageName, name).replace(resolvableExtensionsPattern, '');\n        let runtimeRenameLookup = runtime.split('\\\\').join('/');\n        if (renamedModules && renamedModules[runtimeRenameLookup]) {\n          runtime = renamedModules[runtimeRenameLookup];\n        }\n        runtime = runtime.split(sep).join('/');\n        lazyModules.push({\n          runtime,\n          buildtime: posix.join(packageName, name),\n        });\n      }\n    }\n    // we don't recurse across an engine boundary. Engines import their own\n    // implicit-modules.\n    if (!dep.isEngine()) {\n      eagerModules.push(posix.join(dep.name, `-embroider-${type}.js`));\n    }\n  }\n  return implicitModulesTemplate({ lazyModules, eagerModules });\n}\n\nconst implicitModulesTemplate = compile(`\nimport { importSync as i } from '@embroider/macros';\nlet d = window.define;\n{{#each lazyModules as |module|}}\nd(\"{{js-string-escape module.runtime}}\", function(){ return i(\"{{js-string-escape module.buildtime}}\");});\n{{/each}}\n{{#each eagerModules as |module|}}\nimport \"{{js-string-escape module}}\";\n{{/each}}\n`) as (params: { eagerModules: string[]; lazyModules: { runtime: string; buildtime: string }[] }) => string;\n\n// meta['renamed-modules'] has mapping from classic filename to real filename.\n// This takes that and converts it to the inverst mapping from real import path\n// to classic import path.\nfunction inverseRenamedModules(meta: AddonPackage['meta'], extensions: RegExp) {\n  let renamed = meta['renamed-modules'];\n  if (renamed) {\n    let inverted = {} as { [name: string]: string };\n    for (let [classic, real] of Object.entries(renamed)) {\n      inverted[real.replace(extensions, '')] = classic.replace(extensions, '');\n    }\n    return inverted;\n  }\n}\n\nfunction orderAddons(depA: Package, depB: Package): number {\n  let depAIdx = 0;\n  let depBIdx = 0;\n\n  if (depA && depA.meta && depA.isV2Addon()) {\n    depAIdx = depA.meta['order-index'] || 0;\n  }\n  if (depB && depB.meta && depB.isV2Addon()) {\n    depBIdx = depB.meta['order-index'] || 0;\n  }\n\n  return depAIdx - depBIdx;\n}\n\nconst renderCJSExternalShim = compile(`\n{{#if (eq moduleName \"require\")}}\nconst m = window.requirejs;\n{{else}}\nconst m = window.require(\"{{{js-string-escape moduleName}}}\");\n{{/if}}\n{{!-\n  There are plenty of hand-written AMD defines floating around\n  that lack this, and they will break when other build systems\n  encounter them.\n\n  As far as I can tell, Ember's loader was already treating this\n  case as a module, so in theory we aren't breaking anything by\n  marking it as such when other packagers come looking.\n\n  todo: get review on this part.\n-}}\nif (m.default && !m.__esModule) {\n  m.__esModule = true;\n}\nmodule.exports = m;\n`) as (params: { moduleName: string }) => string;\n"]}